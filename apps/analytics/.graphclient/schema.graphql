enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

scalar BigInt

type ETHEREUM__Block_ {
  """The hash of the block"""
  hash: ETHEREUM_Bytes

  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type ETHEREUM__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: ETHEREUM__Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar ETHEREUM_BigDecimal

"""The block at which the query should be executed."""
input ETHEREUM_Block_height {
  """Value containing a block hash"""
  hash: ETHEREUM_Bytes

  """Value containing a block number"""
  number: Int

  """
  Value containing the minimum block number. 
  In the case of `number_gte`, the query will be executed on the latest block only if
  the subgraph has progressed to or past the minimum block number.
  Defaults to the latest block when omitted.
  
  """
  number_gte: Int
}

type ETHEREUM_Bundle {
  id: ID!
  ethPrice: ETHEREUM_BigDecimal!
}

input ETHEREUM_Bundle_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  ethPrice: ETHEREUM_BigDecimal
  ethPrice_not: ETHEREUM_BigDecimal
  ethPrice_gt: ETHEREUM_BigDecimal
  ethPrice_lt: ETHEREUM_BigDecimal
  ethPrice_gte: ETHEREUM_BigDecimal
  ethPrice_lte: ETHEREUM_BigDecimal
  ethPrice_in: [ETHEREUM_BigDecimal!]
  ethPrice_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_Bundle_orderBy {
  id
  ethPrice
}

type ETHEREUM_Burn {
  id: ID!
  transaction: ETHEREUM_Transaction!
  timestamp: BigInt!
  pair: ETHEREUM_Pair!
  liquidity: ETHEREUM_BigDecimal!
  sender: ETHEREUM_Bytes
  amount0: ETHEREUM_BigDecimal
  amount1: ETHEREUM_BigDecimal
  to: ETHEREUM_Bytes
  logIndex: BigInt
  amountUSD: ETHEREUM_BigDecimal
  complete: Boolean!
  feeTo: ETHEREUM_Bytes
  feeLiquidity: ETHEREUM_BigDecimal
}

input ETHEREUM_Burn_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  liquidity: ETHEREUM_BigDecimal
  liquidity_not: ETHEREUM_BigDecimal
  liquidity_gt: ETHEREUM_BigDecimal
  liquidity_lt: ETHEREUM_BigDecimal
  liquidity_gte: ETHEREUM_BigDecimal
  liquidity_lte: ETHEREUM_BigDecimal
  liquidity_in: [ETHEREUM_BigDecimal!]
  liquidity_not_in: [ETHEREUM_BigDecimal!]
  sender: ETHEREUM_Bytes
  sender_not: ETHEREUM_Bytes
  sender_in: [ETHEREUM_Bytes!]
  sender_not_in: [ETHEREUM_Bytes!]
  sender_contains: ETHEREUM_Bytes
  sender_not_contains: ETHEREUM_Bytes
  amount0: ETHEREUM_BigDecimal
  amount0_not: ETHEREUM_BigDecimal
  amount0_gt: ETHEREUM_BigDecimal
  amount0_lt: ETHEREUM_BigDecimal
  amount0_gte: ETHEREUM_BigDecimal
  amount0_lte: ETHEREUM_BigDecimal
  amount0_in: [ETHEREUM_BigDecimal!]
  amount0_not_in: [ETHEREUM_BigDecimal!]
  amount1: ETHEREUM_BigDecimal
  amount1_not: ETHEREUM_BigDecimal
  amount1_gt: ETHEREUM_BigDecimal
  amount1_lt: ETHEREUM_BigDecimal
  amount1_gte: ETHEREUM_BigDecimal
  amount1_lte: ETHEREUM_BigDecimal
  amount1_in: [ETHEREUM_BigDecimal!]
  amount1_not_in: [ETHEREUM_BigDecimal!]
  to: ETHEREUM_Bytes
  to_not: ETHEREUM_Bytes
  to_in: [ETHEREUM_Bytes!]
  to_not_in: [ETHEREUM_Bytes!]
  to_contains: ETHEREUM_Bytes
  to_not_contains: ETHEREUM_Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  amountUSD: ETHEREUM_BigDecimal
  amountUSD_not: ETHEREUM_BigDecimal
  amountUSD_gt: ETHEREUM_BigDecimal
  amountUSD_lt: ETHEREUM_BigDecimal
  amountUSD_gte: ETHEREUM_BigDecimal
  amountUSD_lte: ETHEREUM_BigDecimal
  amountUSD_in: [ETHEREUM_BigDecimal!]
  amountUSD_not_in: [ETHEREUM_BigDecimal!]
  complete: Boolean
  complete_not: Boolean
  complete_in: [Boolean!]
  complete_not_in: [Boolean!]
  feeTo: ETHEREUM_Bytes
  feeTo_not: ETHEREUM_Bytes
  feeTo_in: [ETHEREUM_Bytes!]
  feeTo_not_in: [ETHEREUM_Bytes!]
  feeTo_contains: ETHEREUM_Bytes
  feeTo_not_contains: ETHEREUM_Bytes
  feeLiquidity: ETHEREUM_BigDecimal
  feeLiquidity_not: ETHEREUM_BigDecimal
  feeLiquidity_gt: ETHEREUM_BigDecimal
  feeLiquidity_lt: ETHEREUM_BigDecimal
  feeLiquidity_gte: ETHEREUM_BigDecimal
  feeLiquidity_lte: ETHEREUM_BigDecimal
  feeLiquidity_in: [ETHEREUM_BigDecimal!]
  feeLiquidity_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_Burn_orderBy {
  id
  transaction
  timestamp
  pair
  liquidity
  sender
  amount0
  amount1
  to
  logIndex
  amountUSD
  complete
  feeTo
  feeLiquidity
}

scalar ETHEREUM_Bytes

type ETHEREUM_DayData {
  id: ID!
  date: Int!
  factory: ETHEREUM_Factory!
  volumeETH: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  untrackedVolume: ETHEREUM_BigDecimal!
  liquidityETH: ETHEREUM_BigDecimal!
  liquidityUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
}

input ETHEREUM_DayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  volumeETH: ETHEREUM_BigDecimal
  volumeETH_not: ETHEREUM_BigDecimal
  volumeETH_gt: ETHEREUM_BigDecimal
  volumeETH_lt: ETHEREUM_BigDecimal
  volumeETH_gte: ETHEREUM_BigDecimal
  volumeETH_lte: ETHEREUM_BigDecimal
  volumeETH_in: [ETHEREUM_BigDecimal!]
  volumeETH_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  untrackedVolume: ETHEREUM_BigDecimal
  untrackedVolume_not: ETHEREUM_BigDecimal
  untrackedVolume_gt: ETHEREUM_BigDecimal
  untrackedVolume_lt: ETHEREUM_BigDecimal
  untrackedVolume_gte: ETHEREUM_BigDecimal
  untrackedVolume_lte: ETHEREUM_BigDecimal
  untrackedVolume_in: [ETHEREUM_BigDecimal!]
  untrackedVolume_not_in: [ETHEREUM_BigDecimal!]
  liquidityETH: ETHEREUM_BigDecimal
  liquidityETH_not: ETHEREUM_BigDecimal
  liquidityETH_gt: ETHEREUM_BigDecimal
  liquidityETH_lt: ETHEREUM_BigDecimal
  liquidityETH_gte: ETHEREUM_BigDecimal
  liquidityETH_lte: ETHEREUM_BigDecimal
  liquidityETH_in: [ETHEREUM_BigDecimal!]
  liquidityETH_not_in: [ETHEREUM_BigDecimal!]
  liquidityUSD: ETHEREUM_BigDecimal
  liquidityUSD_not: ETHEREUM_BigDecimal
  liquidityUSD_gt: ETHEREUM_BigDecimal
  liquidityUSD_lt: ETHEREUM_BigDecimal
  liquidityUSD_gte: ETHEREUM_BigDecimal
  liquidityUSD_lte: ETHEREUM_BigDecimal
  liquidityUSD_in: [ETHEREUM_BigDecimal!]
  liquidityUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum ETHEREUM_DayData_orderBy {
  id
  date
  factory
  volumeETH
  volumeUSD
  untrackedVolume
  liquidityETH
  liquidityUSD
  txCount
}

type ETHEREUM_Factory {
  id: ID!
  pairCount: BigInt!
  volumeUSD: ETHEREUM_BigDecimal!
  volumeETH: ETHEREUM_BigDecimal!
  untrackedVolumeUSD: ETHEREUM_BigDecimal!
  liquidityUSD: ETHEREUM_BigDecimal!
  liquidityETH: ETHEREUM_BigDecimal!
  txCount: BigInt!
  tokenCount: BigInt!
  userCount: BigInt!
  pairs(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Pair_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Pair_filter): [ETHEREUM_Pair!]!
  tokens(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Token_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Token_filter): [ETHEREUM_Token!]!
  hourData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_HourData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_HourData_filter): [ETHEREUM_HourData!]!
  dayData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_DayData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_DayData_filter): [ETHEREUM_DayData!]!
}

input ETHEREUM_Factory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pairCount: BigInt
  pairCount_not: BigInt
  pairCount_gt: BigInt
  pairCount_lt: BigInt
  pairCount_gte: BigInt
  pairCount_lte: BigInt
  pairCount_in: [BigInt!]
  pairCount_not_in: [BigInt!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  volumeETH: ETHEREUM_BigDecimal
  volumeETH_not: ETHEREUM_BigDecimal
  volumeETH_gt: ETHEREUM_BigDecimal
  volumeETH_lt: ETHEREUM_BigDecimal
  volumeETH_gte: ETHEREUM_BigDecimal
  volumeETH_lte: ETHEREUM_BigDecimal
  volumeETH_in: [ETHEREUM_BigDecimal!]
  volumeETH_not_in: [ETHEREUM_BigDecimal!]
  untrackedVolumeUSD: ETHEREUM_BigDecimal
  untrackedVolumeUSD_not: ETHEREUM_BigDecimal
  untrackedVolumeUSD_gt: ETHEREUM_BigDecimal
  untrackedVolumeUSD_lt: ETHEREUM_BigDecimal
  untrackedVolumeUSD_gte: ETHEREUM_BigDecimal
  untrackedVolumeUSD_lte: ETHEREUM_BigDecimal
  untrackedVolumeUSD_in: [ETHEREUM_BigDecimal!]
  untrackedVolumeUSD_not_in: [ETHEREUM_BigDecimal!]
  liquidityUSD: ETHEREUM_BigDecimal
  liquidityUSD_not: ETHEREUM_BigDecimal
  liquidityUSD_gt: ETHEREUM_BigDecimal
  liquidityUSD_lt: ETHEREUM_BigDecimal
  liquidityUSD_gte: ETHEREUM_BigDecimal
  liquidityUSD_lte: ETHEREUM_BigDecimal
  liquidityUSD_in: [ETHEREUM_BigDecimal!]
  liquidityUSD_not_in: [ETHEREUM_BigDecimal!]
  liquidityETH: ETHEREUM_BigDecimal
  liquidityETH_not: ETHEREUM_BigDecimal
  liquidityETH_gt: ETHEREUM_BigDecimal
  liquidityETH_lt: ETHEREUM_BigDecimal
  liquidityETH_gte: ETHEREUM_BigDecimal
  liquidityETH_lte: ETHEREUM_BigDecimal
  liquidityETH_in: [ETHEREUM_BigDecimal!]
  liquidityETH_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  tokenCount: BigInt
  tokenCount_not: BigInt
  tokenCount_gt: BigInt
  tokenCount_lt: BigInt
  tokenCount_gte: BigInt
  tokenCount_lte: BigInt
  tokenCount_in: [BigInt!]
  tokenCount_not_in: [BigInt!]
  userCount: BigInt
  userCount_not: BigInt
  userCount_gt: BigInt
  userCount_lt: BigInt
  userCount_gte: BigInt
  userCount_lte: BigInt
  userCount_in: [BigInt!]
  userCount_not_in: [BigInt!]
}

enum ETHEREUM_Factory_orderBy {
  id
  pairCount
  volumeUSD
  volumeETH
  untrackedVolumeUSD
  liquidityUSD
  liquidityETH
  txCount
  tokenCount
  userCount
  pairs
  tokens
  hourData
  dayData
}

type ETHEREUM_HourData {
  id: ID!
  date: Int!
  factory: ETHEREUM_Factory!
  volumeETH: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  untrackedVolume: ETHEREUM_BigDecimal!
  liquidityETH: ETHEREUM_BigDecimal!
  liquidityUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
}

input ETHEREUM_HourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  volumeETH: ETHEREUM_BigDecimal
  volumeETH_not: ETHEREUM_BigDecimal
  volumeETH_gt: ETHEREUM_BigDecimal
  volumeETH_lt: ETHEREUM_BigDecimal
  volumeETH_gte: ETHEREUM_BigDecimal
  volumeETH_lte: ETHEREUM_BigDecimal
  volumeETH_in: [ETHEREUM_BigDecimal!]
  volumeETH_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  untrackedVolume: ETHEREUM_BigDecimal
  untrackedVolume_not: ETHEREUM_BigDecimal
  untrackedVolume_gt: ETHEREUM_BigDecimal
  untrackedVolume_lt: ETHEREUM_BigDecimal
  untrackedVolume_gte: ETHEREUM_BigDecimal
  untrackedVolume_lte: ETHEREUM_BigDecimal
  untrackedVolume_in: [ETHEREUM_BigDecimal!]
  untrackedVolume_not_in: [ETHEREUM_BigDecimal!]
  liquidityETH: ETHEREUM_BigDecimal
  liquidityETH_not: ETHEREUM_BigDecimal
  liquidityETH_gt: ETHEREUM_BigDecimal
  liquidityETH_lt: ETHEREUM_BigDecimal
  liquidityETH_gte: ETHEREUM_BigDecimal
  liquidityETH_lte: ETHEREUM_BigDecimal
  liquidityETH_in: [ETHEREUM_BigDecimal!]
  liquidityETH_not_in: [ETHEREUM_BigDecimal!]
  liquidityUSD: ETHEREUM_BigDecimal
  liquidityUSD_not: ETHEREUM_BigDecimal
  liquidityUSD_gt: ETHEREUM_BigDecimal
  liquidityUSD_lt: ETHEREUM_BigDecimal
  liquidityUSD_gte: ETHEREUM_BigDecimal
  liquidityUSD_lte: ETHEREUM_BigDecimal
  liquidityUSD_in: [ETHEREUM_BigDecimal!]
  liquidityUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum ETHEREUM_HourData_orderBy {
  id
  date
  factory
  volumeETH
  volumeUSD
  untrackedVolume
  liquidityETH
  liquidityUSD
  txCount
}

type ETHEREUM_LiquidityPosition {
  id: ID!
  user: ETHEREUM_User!
  pair: ETHEREUM_Pair!
  liquidityTokenBalance: ETHEREUM_BigDecimal!
  snapshots(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_LiquidityPositionSnapshot_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_LiquidityPositionSnapshot_filter): [ETHEREUM_LiquidityPositionSnapshot]!
  block: Int!
  timestamp: Int!
}

input ETHEREUM_LiquidityPosition_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  liquidityTokenBalance: ETHEREUM_BigDecimal
  liquidityTokenBalance_not: ETHEREUM_BigDecimal
  liquidityTokenBalance_gt: ETHEREUM_BigDecimal
  liquidityTokenBalance_lt: ETHEREUM_BigDecimal
  liquidityTokenBalance_gte: ETHEREUM_BigDecimal
  liquidityTokenBalance_lte: ETHEREUM_BigDecimal
  liquidityTokenBalance_in: [ETHEREUM_BigDecimal!]
  liquidityTokenBalance_not_in: [ETHEREUM_BigDecimal!]
  block: Int
  block_not: Int
  block_gt: Int
  block_lt: Int
  block_gte: Int
  block_lte: Int
  block_in: [Int!]
  block_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
}

enum ETHEREUM_LiquidityPosition_orderBy {
  id
  user
  pair
  liquidityTokenBalance
  snapshots
  block
  timestamp
}

type ETHEREUM_LiquidityPositionSnapshot {
  id: ID!
  liquidityPosition: ETHEREUM_LiquidityPosition!
  timestamp: Int!
  block: Int!
  user: ETHEREUM_User!
  pair: ETHEREUM_Pair!
  token0PriceUSD: ETHEREUM_BigDecimal!
  token1PriceUSD: ETHEREUM_BigDecimal!
  reserve0: ETHEREUM_BigDecimal!
  reserve1: ETHEREUM_BigDecimal!
  reserveUSD: ETHEREUM_BigDecimal!
  liquidityTokenTotalSupply: ETHEREUM_BigDecimal!
  liquidityTokenBalance: ETHEREUM_BigDecimal!
}

input ETHEREUM_LiquidityPositionSnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  liquidityPosition: String
  liquidityPosition_not: String
  liquidityPosition_gt: String
  liquidityPosition_lt: String
  liquidityPosition_gte: String
  liquidityPosition_lte: String
  liquidityPosition_in: [String!]
  liquidityPosition_not_in: [String!]
  liquidityPosition_contains: String
  liquidityPosition_contains_nocase: String
  liquidityPosition_not_contains: String
  liquidityPosition_not_contains_nocase: String
  liquidityPosition_starts_with: String
  liquidityPosition_starts_with_nocase: String
  liquidityPosition_not_starts_with: String
  liquidityPosition_not_starts_with_nocase: String
  liquidityPosition_ends_with: String
  liquidityPosition_ends_with_nocase: String
  liquidityPosition_not_ends_with: String
  liquidityPosition_not_ends_with_nocase: String
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  block: Int
  block_not: Int
  block_gt: Int
  block_lt: Int
  block_gte: Int
  block_lte: Int
  block_in: [Int!]
  block_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  token0PriceUSD: ETHEREUM_BigDecimal
  token0PriceUSD_not: ETHEREUM_BigDecimal
  token0PriceUSD_gt: ETHEREUM_BigDecimal
  token0PriceUSD_lt: ETHEREUM_BigDecimal
  token0PriceUSD_gte: ETHEREUM_BigDecimal
  token0PriceUSD_lte: ETHEREUM_BigDecimal
  token0PriceUSD_in: [ETHEREUM_BigDecimal!]
  token0PriceUSD_not_in: [ETHEREUM_BigDecimal!]
  token1PriceUSD: ETHEREUM_BigDecimal
  token1PriceUSD_not: ETHEREUM_BigDecimal
  token1PriceUSD_gt: ETHEREUM_BigDecimal
  token1PriceUSD_lt: ETHEREUM_BigDecimal
  token1PriceUSD_gte: ETHEREUM_BigDecimal
  token1PriceUSD_lte: ETHEREUM_BigDecimal
  token1PriceUSD_in: [ETHEREUM_BigDecimal!]
  token1PriceUSD_not_in: [ETHEREUM_BigDecimal!]
  reserve0: ETHEREUM_BigDecimal
  reserve0_not: ETHEREUM_BigDecimal
  reserve0_gt: ETHEREUM_BigDecimal
  reserve0_lt: ETHEREUM_BigDecimal
  reserve0_gte: ETHEREUM_BigDecimal
  reserve0_lte: ETHEREUM_BigDecimal
  reserve0_in: [ETHEREUM_BigDecimal!]
  reserve0_not_in: [ETHEREUM_BigDecimal!]
  reserve1: ETHEREUM_BigDecimal
  reserve1_not: ETHEREUM_BigDecimal
  reserve1_gt: ETHEREUM_BigDecimal
  reserve1_lt: ETHEREUM_BigDecimal
  reserve1_gte: ETHEREUM_BigDecimal
  reserve1_lte: ETHEREUM_BigDecimal
  reserve1_in: [ETHEREUM_BigDecimal!]
  reserve1_not_in: [ETHEREUM_BigDecimal!]
  reserveUSD: ETHEREUM_BigDecimal
  reserveUSD_not: ETHEREUM_BigDecimal
  reserveUSD_gt: ETHEREUM_BigDecimal
  reserveUSD_lt: ETHEREUM_BigDecimal
  reserveUSD_gte: ETHEREUM_BigDecimal
  reserveUSD_lte: ETHEREUM_BigDecimal
  reserveUSD_in: [ETHEREUM_BigDecimal!]
  reserveUSD_not_in: [ETHEREUM_BigDecimal!]
  liquidityTokenTotalSupply: ETHEREUM_BigDecimal
  liquidityTokenTotalSupply_not: ETHEREUM_BigDecimal
  liquidityTokenTotalSupply_gt: ETHEREUM_BigDecimal
  liquidityTokenTotalSupply_lt: ETHEREUM_BigDecimal
  liquidityTokenTotalSupply_gte: ETHEREUM_BigDecimal
  liquidityTokenTotalSupply_lte: ETHEREUM_BigDecimal
  liquidityTokenTotalSupply_in: [ETHEREUM_BigDecimal!]
  liquidityTokenTotalSupply_not_in: [ETHEREUM_BigDecimal!]
  liquidityTokenBalance: ETHEREUM_BigDecimal
  liquidityTokenBalance_not: ETHEREUM_BigDecimal
  liquidityTokenBalance_gt: ETHEREUM_BigDecimal
  liquidityTokenBalance_lt: ETHEREUM_BigDecimal
  liquidityTokenBalance_gte: ETHEREUM_BigDecimal
  liquidityTokenBalance_lte: ETHEREUM_BigDecimal
  liquidityTokenBalance_in: [ETHEREUM_BigDecimal!]
  liquidityTokenBalance_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_LiquidityPositionSnapshot_orderBy {
  id
  liquidityPosition
  timestamp
  block
  user
  pair
  token0PriceUSD
  token1PriceUSD
  reserve0
  reserve1
  reserveUSD
  liquidityTokenTotalSupply
  liquidityTokenBalance
}

type ETHEREUM_Mint {
  id: ID!
  transaction: ETHEREUM_Transaction!
  timestamp: BigInt!
  pair: ETHEREUM_Pair!
  to: ETHEREUM_Bytes!
  liquidity: ETHEREUM_BigDecimal!
  sender: ETHEREUM_Bytes
  amount0: ETHEREUM_BigDecimal
  amount1: ETHEREUM_BigDecimal
  logIndex: BigInt
  amountUSD: ETHEREUM_BigDecimal
  feeTo: ETHEREUM_Bytes
  feeLiquidity: ETHEREUM_BigDecimal
}

input ETHEREUM_Mint_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  to: ETHEREUM_Bytes
  to_not: ETHEREUM_Bytes
  to_in: [ETHEREUM_Bytes!]
  to_not_in: [ETHEREUM_Bytes!]
  to_contains: ETHEREUM_Bytes
  to_not_contains: ETHEREUM_Bytes
  liquidity: ETHEREUM_BigDecimal
  liquidity_not: ETHEREUM_BigDecimal
  liquidity_gt: ETHEREUM_BigDecimal
  liquidity_lt: ETHEREUM_BigDecimal
  liquidity_gte: ETHEREUM_BigDecimal
  liquidity_lte: ETHEREUM_BigDecimal
  liquidity_in: [ETHEREUM_BigDecimal!]
  liquidity_not_in: [ETHEREUM_BigDecimal!]
  sender: ETHEREUM_Bytes
  sender_not: ETHEREUM_Bytes
  sender_in: [ETHEREUM_Bytes!]
  sender_not_in: [ETHEREUM_Bytes!]
  sender_contains: ETHEREUM_Bytes
  sender_not_contains: ETHEREUM_Bytes
  amount0: ETHEREUM_BigDecimal
  amount0_not: ETHEREUM_BigDecimal
  amount0_gt: ETHEREUM_BigDecimal
  amount0_lt: ETHEREUM_BigDecimal
  amount0_gte: ETHEREUM_BigDecimal
  amount0_lte: ETHEREUM_BigDecimal
  amount0_in: [ETHEREUM_BigDecimal!]
  amount0_not_in: [ETHEREUM_BigDecimal!]
  amount1: ETHEREUM_BigDecimal
  amount1_not: ETHEREUM_BigDecimal
  amount1_gt: ETHEREUM_BigDecimal
  amount1_lt: ETHEREUM_BigDecimal
  amount1_gte: ETHEREUM_BigDecimal
  amount1_lte: ETHEREUM_BigDecimal
  amount1_in: [ETHEREUM_BigDecimal!]
  amount1_not_in: [ETHEREUM_BigDecimal!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  amountUSD: ETHEREUM_BigDecimal
  amountUSD_not: ETHEREUM_BigDecimal
  amountUSD_gt: ETHEREUM_BigDecimal
  amountUSD_lt: ETHEREUM_BigDecimal
  amountUSD_gte: ETHEREUM_BigDecimal
  amountUSD_lte: ETHEREUM_BigDecimal
  amountUSD_in: [ETHEREUM_BigDecimal!]
  amountUSD_not_in: [ETHEREUM_BigDecimal!]
  feeTo: ETHEREUM_Bytes
  feeTo_not: ETHEREUM_Bytes
  feeTo_in: [ETHEREUM_Bytes!]
  feeTo_not_in: [ETHEREUM_Bytes!]
  feeTo_contains: ETHEREUM_Bytes
  feeTo_not_contains: ETHEREUM_Bytes
  feeLiquidity: ETHEREUM_BigDecimal
  feeLiquidity_not: ETHEREUM_BigDecimal
  feeLiquidity_gt: ETHEREUM_BigDecimal
  feeLiquidity_lt: ETHEREUM_BigDecimal
  feeLiquidity_gte: ETHEREUM_BigDecimal
  feeLiquidity_lte: ETHEREUM_BigDecimal
  feeLiquidity_in: [ETHEREUM_BigDecimal!]
  feeLiquidity_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_Mint_orderBy {
  id
  transaction
  timestamp
  pair
  to
  liquidity
  sender
  amount0
  amount1
  logIndex
  amountUSD
  feeTo
  feeLiquidity
}

"""Defines the order direction, either ascending or descending"""
enum ETHEREUM_OrderDirection {
  asc
  desc
}

type ETHEREUM_Pair {
  id: ID!
  factory: ETHEREUM_Factory!
  name: String!
  token0: ETHEREUM_Token!
  token1: ETHEREUM_Token!
  reserve0: ETHEREUM_BigDecimal!
  reserve1: ETHEREUM_BigDecimal!
  totalSupply: ETHEREUM_BigDecimal!
  reserveETH: ETHEREUM_BigDecimal!
  reserveUSD: ETHEREUM_BigDecimal!
  trackedReserveETH: ETHEREUM_BigDecimal!
  token0Price: ETHEREUM_BigDecimal!
  token1Price: ETHEREUM_BigDecimal!
  volumeToken0: ETHEREUM_BigDecimal!
  volumeToken1: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  untrackedVolumeUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
  liquidityProviderCount: BigInt!
  liquidityPositions(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_LiquidityPosition_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_LiquidityPosition_filter): [ETHEREUM_LiquidityPosition!]!
  liquidityPositionSnapshots(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_LiquidityPositionSnapshot_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_LiquidityPositionSnapshot_filter): [ETHEREUM_LiquidityPositionSnapshot!]!
  dayData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_PairDayData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_PairDayData_filter): [ETHEREUM_PairDayData!]!
  hourData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_PairHourData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_PairHourData_filter): [ETHEREUM_PairHourData!]!
  mints(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Mint_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Mint_filter): [ETHEREUM_Mint!]!
  burns(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Burn_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Burn_filter): [ETHEREUM_Burn!]!
  swaps(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Swap_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Swap_filter): [ETHEREUM_Swap!]!
  timestamp: BigInt!
  block: BigInt!
}

input ETHEREUM_Pair_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  reserve0: ETHEREUM_BigDecimal
  reserve0_not: ETHEREUM_BigDecimal
  reserve0_gt: ETHEREUM_BigDecimal
  reserve0_lt: ETHEREUM_BigDecimal
  reserve0_gte: ETHEREUM_BigDecimal
  reserve0_lte: ETHEREUM_BigDecimal
  reserve0_in: [ETHEREUM_BigDecimal!]
  reserve0_not_in: [ETHEREUM_BigDecimal!]
  reserve1: ETHEREUM_BigDecimal
  reserve1_not: ETHEREUM_BigDecimal
  reserve1_gt: ETHEREUM_BigDecimal
  reserve1_lt: ETHEREUM_BigDecimal
  reserve1_gte: ETHEREUM_BigDecimal
  reserve1_lte: ETHEREUM_BigDecimal
  reserve1_in: [ETHEREUM_BigDecimal!]
  reserve1_not_in: [ETHEREUM_BigDecimal!]
  totalSupply: ETHEREUM_BigDecimal
  totalSupply_not: ETHEREUM_BigDecimal
  totalSupply_gt: ETHEREUM_BigDecimal
  totalSupply_lt: ETHEREUM_BigDecimal
  totalSupply_gte: ETHEREUM_BigDecimal
  totalSupply_lte: ETHEREUM_BigDecimal
  totalSupply_in: [ETHEREUM_BigDecimal!]
  totalSupply_not_in: [ETHEREUM_BigDecimal!]
  reserveETH: ETHEREUM_BigDecimal
  reserveETH_not: ETHEREUM_BigDecimal
  reserveETH_gt: ETHEREUM_BigDecimal
  reserveETH_lt: ETHEREUM_BigDecimal
  reserveETH_gte: ETHEREUM_BigDecimal
  reserveETH_lte: ETHEREUM_BigDecimal
  reserveETH_in: [ETHEREUM_BigDecimal!]
  reserveETH_not_in: [ETHEREUM_BigDecimal!]
  reserveUSD: ETHEREUM_BigDecimal
  reserveUSD_not: ETHEREUM_BigDecimal
  reserveUSD_gt: ETHEREUM_BigDecimal
  reserveUSD_lt: ETHEREUM_BigDecimal
  reserveUSD_gte: ETHEREUM_BigDecimal
  reserveUSD_lte: ETHEREUM_BigDecimal
  reserveUSD_in: [ETHEREUM_BigDecimal!]
  reserveUSD_not_in: [ETHEREUM_BigDecimal!]
  trackedReserveETH: ETHEREUM_BigDecimal
  trackedReserveETH_not: ETHEREUM_BigDecimal
  trackedReserveETH_gt: ETHEREUM_BigDecimal
  trackedReserveETH_lt: ETHEREUM_BigDecimal
  trackedReserveETH_gte: ETHEREUM_BigDecimal
  trackedReserveETH_lte: ETHEREUM_BigDecimal
  trackedReserveETH_in: [ETHEREUM_BigDecimal!]
  trackedReserveETH_not_in: [ETHEREUM_BigDecimal!]
  token0Price: ETHEREUM_BigDecimal
  token0Price_not: ETHEREUM_BigDecimal
  token0Price_gt: ETHEREUM_BigDecimal
  token0Price_lt: ETHEREUM_BigDecimal
  token0Price_gte: ETHEREUM_BigDecimal
  token0Price_lte: ETHEREUM_BigDecimal
  token0Price_in: [ETHEREUM_BigDecimal!]
  token0Price_not_in: [ETHEREUM_BigDecimal!]
  token1Price: ETHEREUM_BigDecimal
  token1Price_not: ETHEREUM_BigDecimal
  token1Price_gt: ETHEREUM_BigDecimal
  token1Price_lt: ETHEREUM_BigDecimal
  token1Price_gte: ETHEREUM_BigDecimal
  token1Price_lte: ETHEREUM_BigDecimal
  token1Price_in: [ETHEREUM_BigDecimal!]
  token1Price_not_in: [ETHEREUM_BigDecimal!]
  volumeToken0: ETHEREUM_BigDecimal
  volumeToken0_not: ETHEREUM_BigDecimal
  volumeToken0_gt: ETHEREUM_BigDecimal
  volumeToken0_lt: ETHEREUM_BigDecimal
  volumeToken0_gte: ETHEREUM_BigDecimal
  volumeToken0_lte: ETHEREUM_BigDecimal
  volumeToken0_in: [ETHEREUM_BigDecimal!]
  volumeToken0_not_in: [ETHEREUM_BigDecimal!]
  volumeToken1: ETHEREUM_BigDecimal
  volumeToken1_not: ETHEREUM_BigDecimal
  volumeToken1_gt: ETHEREUM_BigDecimal
  volumeToken1_lt: ETHEREUM_BigDecimal
  volumeToken1_gte: ETHEREUM_BigDecimal
  volumeToken1_lte: ETHEREUM_BigDecimal
  volumeToken1_in: [ETHEREUM_BigDecimal!]
  volumeToken1_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  untrackedVolumeUSD: ETHEREUM_BigDecimal
  untrackedVolumeUSD_not: ETHEREUM_BigDecimal
  untrackedVolumeUSD_gt: ETHEREUM_BigDecimal
  untrackedVolumeUSD_lt: ETHEREUM_BigDecimal
  untrackedVolumeUSD_gte: ETHEREUM_BigDecimal
  untrackedVolumeUSD_lte: ETHEREUM_BigDecimal
  untrackedVolumeUSD_in: [ETHEREUM_BigDecimal!]
  untrackedVolumeUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidityProviderCount: BigInt
  liquidityProviderCount_not: BigInt
  liquidityProviderCount_gt: BigInt
  liquidityProviderCount_lt: BigInt
  liquidityProviderCount_gte: BigInt
  liquidityProviderCount_lte: BigInt
  liquidityProviderCount_in: [BigInt!]
  liquidityProviderCount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
}

enum ETHEREUM_Pair_orderBy {
  id
  factory
  name
  token0
  token1
  reserve0
  reserve1
  totalSupply
  reserveETH
  reserveUSD
  trackedReserveETH
  token0Price
  token1Price
  volumeToken0
  volumeToken1
  volumeUSD
  untrackedVolumeUSD
  txCount
  liquidityProviderCount
  liquidityPositions
  liquidityPositionSnapshots
  dayData
  hourData
  mints
  burns
  swaps
  timestamp
  block
}

type ETHEREUM_PairDayData {
  id: ID!
  date: Int!
  pair: ETHEREUM_Pair!
  token0: ETHEREUM_Token!
  token1: ETHEREUM_Token!
  reserve0: ETHEREUM_BigDecimal!
  reserve1: ETHEREUM_BigDecimal!
  totalSupply: ETHEREUM_BigDecimal!
  reserveUSD: ETHEREUM_BigDecimal!
  volumeToken0: ETHEREUM_BigDecimal!
  volumeToken1: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
}

input ETHEREUM_PairDayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  reserve0: ETHEREUM_BigDecimal
  reserve0_not: ETHEREUM_BigDecimal
  reserve0_gt: ETHEREUM_BigDecimal
  reserve0_lt: ETHEREUM_BigDecimal
  reserve0_gte: ETHEREUM_BigDecimal
  reserve0_lte: ETHEREUM_BigDecimal
  reserve0_in: [ETHEREUM_BigDecimal!]
  reserve0_not_in: [ETHEREUM_BigDecimal!]
  reserve1: ETHEREUM_BigDecimal
  reserve1_not: ETHEREUM_BigDecimal
  reserve1_gt: ETHEREUM_BigDecimal
  reserve1_lt: ETHEREUM_BigDecimal
  reserve1_gte: ETHEREUM_BigDecimal
  reserve1_lte: ETHEREUM_BigDecimal
  reserve1_in: [ETHEREUM_BigDecimal!]
  reserve1_not_in: [ETHEREUM_BigDecimal!]
  totalSupply: ETHEREUM_BigDecimal
  totalSupply_not: ETHEREUM_BigDecimal
  totalSupply_gt: ETHEREUM_BigDecimal
  totalSupply_lt: ETHEREUM_BigDecimal
  totalSupply_gte: ETHEREUM_BigDecimal
  totalSupply_lte: ETHEREUM_BigDecimal
  totalSupply_in: [ETHEREUM_BigDecimal!]
  totalSupply_not_in: [ETHEREUM_BigDecimal!]
  reserveUSD: ETHEREUM_BigDecimal
  reserveUSD_not: ETHEREUM_BigDecimal
  reserveUSD_gt: ETHEREUM_BigDecimal
  reserveUSD_lt: ETHEREUM_BigDecimal
  reserveUSD_gte: ETHEREUM_BigDecimal
  reserveUSD_lte: ETHEREUM_BigDecimal
  reserveUSD_in: [ETHEREUM_BigDecimal!]
  reserveUSD_not_in: [ETHEREUM_BigDecimal!]
  volumeToken0: ETHEREUM_BigDecimal
  volumeToken0_not: ETHEREUM_BigDecimal
  volumeToken0_gt: ETHEREUM_BigDecimal
  volumeToken0_lt: ETHEREUM_BigDecimal
  volumeToken0_gte: ETHEREUM_BigDecimal
  volumeToken0_lte: ETHEREUM_BigDecimal
  volumeToken0_in: [ETHEREUM_BigDecimal!]
  volumeToken0_not_in: [ETHEREUM_BigDecimal!]
  volumeToken1: ETHEREUM_BigDecimal
  volumeToken1_not: ETHEREUM_BigDecimal
  volumeToken1_gt: ETHEREUM_BigDecimal
  volumeToken1_lt: ETHEREUM_BigDecimal
  volumeToken1_gte: ETHEREUM_BigDecimal
  volumeToken1_lte: ETHEREUM_BigDecimal
  volumeToken1_in: [ETHEREUM_BigDecimal!]
  volumeToken1_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum ETHEREUM_PairDayData_orderBy {
  id
  date
  pair
  token0
  token1
  reserve0
  reserve1
  totalSupply
  reserveUSD
  volumeToken0
  volumeToken1
  volumeUSD
  txCount
}

type ETHEREUM_PairHourData {
  id: ID!
  date: Int!
  pair: ETHEREUM_Pair!
  reserve0: ETHEREUM_BigDecimal!
  reserve1: ETHEREUM_BigDecimal!
  reserveUSD: ETHEREUM_BigDecimal!
  volumeToken0: ETHEREUM_BigDecimal!
  volumeToken1: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
}

input ETHEREUM_PairHourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  reserve0: ETHEREUM_BigDecimal
  reserve0_not: ETHEREUM_BigDecimal
  reserve0_gt: ETHEREUM_BigDecimal
  reserve0_lt: ETHEREUM_BigDecimal
  reserve0_gte: ETHEREUM_BigDecimal
  reserve0_lte: ETHEREUM_BigDecimal
  reserve0_in: [ETHEREUM_BigDecimal!]
  reserve0_not_in: [ETHEREUM_BigDecimal!]
  reserve1: ETHEREUM_BigDecimal
  reserve1_not: ETHEREUM_BigDecimal
  reserve1_gt: ETHEREUM_BigDecimal
  reserve1_lt: ETHEREUM_BigDecimal
  reserve1_gte: ETHEREUM_BigDecimal
  reserve1_lte: ETHEREUM_BigDecimal
  reserve1_in: [ETHEREUM_BigDecimal!]
  reserve1_not_in: [ETHEREUM_BigDecimal!]
  reserveUSD: ETHEREUM_BigDecimal
  reserveUSD_not: ETHEREUM_BigDecimal
  reserveUSD_gt: ETHEREUM_BigDecimal
  reserveUSD_lt: ETHEREUM_BigDecimal
  reserveUSD_gte: ETHEREUM_BigDecimal
  reserveUSD_lte: ETHEREUM_BigDecimal
  reserveUSD_in: [ETHEREUM_BigDecimal!]
  reserveUSD_not_in: [ETHEREUM_BigDecimal!]
  volumeToken0: ETHEREUM_BigDecimal
  volumeToken0_not: ETHEREUM_BigDecimal
  volumeToken0_gt: ETHEREUM_BigDecimal
  volumeToken0_lt: ETHEREUM_BigDecimal
  volumeToken0_gte: ETHEREUM_BigDecimal
  volumeToken0_lte: ETHEREUM_BigDecimal
  volumeToken0_in: [ETHEREUM_BigDecimal!]
  volumeToken0_not_in: [ETHEREUM_BigDecimal!]
  volumeToken1: ETHEREUM_BigDecimal
  volumeToken1_not: ETHEREUM_BigDecimal
  volumeToken1_gt: ETHEREUM_BigDecimal
  volumeToken1_lt: ETHEREUM_BigDecimal
  volumeToken1_gte: ETHEREUM_BigDecimal
  volumeToken1_lte: ETHEREUM_BigDecimal
  volumeToken1_in: [ETHEREUM_BigDecimal!]
  volumeToken1_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum ETHEREUM_PairHourData_orderBy {
  id
  date
  pair
  reserve0
  reserve1
  reserveUSD
  volumeToken0
  volumeToken1
  volumeUSD
  txCount
}

type ETHEREUM_Swap {
  id: ID!
  transaction: ETHEREUM_Transaction!
  timestamp: BigInt!
  pair: ETHEREUM_Pair!
  sender: ETHEREUM_Bytes!
  amount0In: ETHEREUM_BigDecimal!
  amount1In: ETHEREUM_BigDecimal!
  amount0Out: ETHEREUM_BigDecimal!
  amount1Out: ETHEREUM_BigDecimal!
  to: ETHEREUM_Bytes!
  logIndex: BigInt
  amountUSD: ETHEREUM_BigDecimal!
}

input ETHEREUM_Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  sender: ETHEREUM_Bytes
  sender_not: ETHEREUM_Bytes
  sender_in: [ETHEREUM_Bytes!]
  sender_not_in: [ETHEREUM_Bytes!]
  sender_contains: ETHEREUM_Bytes
  sender_not_contains: ETHEREUM_Bytes
  amount0In: ETHEREUM_BigDecimal
  amount0In_not: ETHEREUM_BigDecimal
  amount0In_gt: ETHEREUM_BigDecimal
  amount0In_lt: ETHEREUM_BigDecimal
  amount0In_gte: ETHEREUM_BigDecimal
  amount0In_lte: ETHEREUM_BigDecimal
  amount0In_in: [ETHEREUM_BigDecimal!]
  amount0In_not_in: [ETHEREUM_BigDecimal!]
  amount1In: ETHEREUM_BigDecimal
  amount1In_not: ETHEREUM_BigDecimal
  amount1In_gt: ETHEREUM_BigDecimal
  amount1In_lt: ETHEREUM_BigDecimal
  amount1In_gte: ETHEREUM_BigDecimal
  amount1In_lte: ETHEREUM_BigDecimal
  amount1In_in: [ETHEREUM_BigDecimal!]
  amount1In_not_in: [ETHEREUM_BigDecimal!]
  amount0Out: ETHEREUM_BigDecimal
  amount0Out_not: ETHEREUM_BigDecimal
  amount0Out_gt: ETHEREUM_BigDecimal
  amount0Out_lt: ETHEREUM_BigDecimal
  amount0Out_gte: ETHEREUM_BigDecimal
  amount0Out_lte: ETHEREUM_BigDecimal
  amount0Out_in: [ETHEREUM_BigDecimal!]
  amount0Out_not_in: [ETHEREUM_BigDecimal!]
  amount1Out: ETHEREUM_BigDecimal
  amount1Out_not: ETHEREUM_BigDecimal
  amount1Out_gt: ETHEREUM_BigDecimal
  amount1Out_lt: ETHEREUM_BigDecimal
  amount1Out_gte: ETHEREUM_BigDecimal
  amount1Out_lte: ETHEREUM_BigDecimal
  amount1Out_in: [ETHEREUM_BigDecimal!]
  amount1Out_not_in: [ETHEREUM_BigDecimal!]
  to: ETHEREUM_Bytes
  to_not: ETHEREUM_Bytes
  to_in: [ETHEREUM_Bytes!]
  to_not_in: [ETHEREUM_Bytes!]
  to_contains: ETHEREUM_Bytes
  to_not_contains: ETHEREUM_Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  amountUSD: ETHEREUM_BigDecimal
  amountUSD_not: ETHEREUM_BigDecimal
  amountUSD_gt: ETHEREUM_BigDecimal
  amountUSD_lt: ETHEREUM_BigDecimal
  amountUSD_gte: ETHEREUM_BigDecimal
  amountUSD_lte: ETHEREUM_BigDecimal
  amountUSD_in: [ETHEREUM_BigDecimal!]
  amountUSD_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_Swap_orderBy {
  id
  transaction
  timestamp
  pair
  sender
  amount0In
  amount1In
  amount0Out
  amount1Out
  to
  logIndex
  amountUSD
}

type ETHEREUM_Token {
  id: ID!
  factory: ETHEREUM_Factory!
  symbol: String!
  name: String!
  decimals: BigInt!
  totalSupply: BigInt!
  volume: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  untrackedVolumeUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
  liquidity: ETHEREUM_BigDecimal!
  derivedETH: ETHEREUM_BigDecimal!
  hourData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_TokenHourData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_TokenHourData_filter): [ETHEREUM_TokenHourData!]!
  dayData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_TokenDayData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_TokenDayData_filter): [ETHEREUM_TokenDayData!]!
  basePairs(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Pair_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Pair_filter): [ETHEREUM_Pair!]!
  quotePairs(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Pair_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Pair_filter): [ETHEREUM_Pair!]!
  basePairsDayData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_PairDayData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_PairDayData_filter): [ETHEREUM_PairDayData!]!
  quotePairsDayData(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_PairDayData_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_PairDayData_filter): [ETHEREUM_PairDayData!]!
}

input ETHEREUM_Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  volume: ETHEREUM_BigDecimal
  volume_not: ETHEREUM_BigDecimal
  volume_gt: ETHEREUM_BigDecimal
  volume_lt: ETHEREUM_BigDecimal
  volume_gte: ETHEREUM_BigDecimal
  volume_lte: ETHEREUM_BigDecimal
  volume_in: [ETHEREUM_BigDecimal!]
  volume_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  untrackedVolumeUSD: ETHEREUM_BigDecimal
  untrackedVolumeUSD_not: ETHEREUM_BigDecimal
  untrackedVolumeUSD_gt: ETHEREUM_BigDecimal
  untrackedVolumeUSD_lt: ETHEREUM_BigDecimal
  untrackedVolumeUSD_gte: ETHEREUM_BigDecimal
  untrackedVolumeUSD_lte: ETHEREUM_BigDecimal
  untrackedVolumeUSD_in: [ETHEREUM_BigDecimal!]
  untrackedVolumeUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidity: ETHEREUM_BigDecimal
  liquidity_not: ETHEREUM_BigDecimal
  liquidity_gt: ETHEREUM_BigDecimal
  liquidity_lt: ETHEREUM_BigDecimal
  liquidity_gte: ETHEREUM_BigDecimal
  liquidity_lte: ETHEREUM_BigDecimal
  liquidity_in: [ETHEREUM_BigDecimal!]
  liquidity_not_in: [ETHEREUM_BigDecimal!]
  derivedETH: ETHEREUM_BigDecimal
  derivedETH_not: ETHEREUM_BigDecimal
  derivedETH_gt: ETHEREUM_BigDecimal
  derivedETH_lt: ETHEREUM_BigDecimal
  derivedETH_gte: ETHEREUM_BigDecimal
  derivedETH_lte: ETHEREUM_BigDecimal
  derivedETH_in: [ETHEREUM_BigDecimal!]
  derivedETH_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_Token_orderBy {
  id
  factory
  symbol
  name
  decimals
  totalSupply
  volume
  volumeUSD
  untrackedVolumeUSD
  txCount
  liquidity
  derivedETH
  hourData
  dayData
  basePairs
  quotePairs
  basePairsDayData
  quotePairsDayData
}

type ETHEREUM_TokenDayData {
  id: ID!
  date: Int!
  token: ETHEREUM_Token!
  volume: ETHEREUM_BigDecimal!
  volumeETH: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
  liquidity: ETHEREUM_BigDecimal!
  liquidityETH: ETHEREUM_BigDecimal!
  liquidityUSD: ETHEREUM_BigDecimal!
  priceUSD: ETHEREUM_BigDecimal!
}

input ETHEREUM_TokenDayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  volume: ETHEREUM_BigDecimal
  volume_not: ETHEREUM_BigDecimal
  volume_gt: ETHEREUM_BigDecimal
  volume_lt: ETHEREUM_BigDecimal
  volume_gte: ETHEREUM_BigDecimal
  volume_lte: ETHEREUM_BigDecimal
  volume_in: [ETHEREUM_BigDecimal!]
  volume_not_in: [ETHEREUM_BigDecimal!]
  volumeETH: ETHEREUM_BigDecimal
  volumeETH_not: ETHEREUM_BigDecimal
  volumeETH_gt: ETHEREUM_BigDecimal
  volumeETH_lt: ETHEREUM_BigDecimal
  volumeETH_gte: ETHEREUM_BigDecimal
  volumeETH_lte: ETHEREUM_BigDecimal
  volumeETH_in: [ETHEREUM_BigDecimal!]
  volumeETH_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidity: ETHEREUM_BigDecimal
  liquidity_not: ETHEREUM_BigDecimal
  liquidity_gt: ETHEREUM_BigDecimal
  liquidity_lt: ETHEREUM_BigDecimal
  liquidity_gte: ETHEREUM_BigDecimal
  liquidity_lte: ETHEREUM_BigDecimal
  liquidity_in: [ETHEREUM_BigDecimal!]
  liquidity_not_in: [ETHEREUM_BigDecimal!]
  liquidityETH: ETHEREUM_BigDecimal
  liquidityETH_not: ETHEREUM_BigDecimal
  liquidityETH_gt: ETHEREUM_BigDecimal
  liquidityETH_lt: ETHEREUM_BigDecimal
  liquidityETH_gte: ETHEREUM_BigDecimal
  liquidityETH_lte: ETHEREUM_BigDecimal
  liquidityETH_in: [ETHEREUM_BigDecimal!]
  liquidityETH_not_in: [ETHEREUM_BigDecimal!]
  liquidityUSD: ETHEREUM_BigDecimal
  liquidityUSD_not: ETHEREUM_BigDecimal
  liquidityUSD_gt: ETHEREUM_BigDecimal
  liquidityUSD_lt: ETHEREUM_BigDecimal
  liquidityUSD_gte: ETHEREUM_BigDecimal
  liquidityUSD_lte: ETHEREUM_BigDecimal
  liquidityUSD_in: [ETHEREUM_BigDecimal!]
  liquidityUSD_not_in: [ETHEREUM_BigDecimal!]
  priceUSD: ETHEREUM_BigDecimal
  priceUSD_not: ETHEREUM_BigDecimal
  priceUSD_gt: ETHEREUM_BigDecimal
  priceUSD_lt: ETHEREUM_BigDecimal
  priceUSD_gte: ETHEREUM_BigDecimal
  priceUSD_lte: ETHEREUM_BigDecimal
  priceUSD_in: [ETHEREUM_BigDecimal!]
  priceUSD_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_TokenDayData_orderBy {
  id
  date
  token
  volume
  volumeETH
  volumeUSD
  txCount
  liquidity
  liquidityETH
  liquidityUSD
  priceUSD
}

type ETHEREUM_TokenHourData {
  id: ID!
  date: Int!
  token: ETHEREUM_Token!
  volume: ETHEREUM_BigDecimal!
  volumeETH: ETHEREUM_BigDecimal!
  volumeUSD: ETHEREUM_BigDecimal!
  txCount: BigInt!
  liquidity: ETHEREUM_BigDecimal!
  liquidityETH: ETHEREUM_BigDecimal!
  liquidityUSD: ETHEREUM_BigDecimal!
  priceUSD: ETHEREUM_BigDecimal!
}

input ETHEREUM_TokenHourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  volume: ETHEREUM_BigDecimal
  volume_not: ETHEREUM_BigDecimal
  volume_gt: ETHEREUM_BigDecimal
  volume_lt: ETHEREUM_BigDecimal
  volume_gte: ETHEREUM_BigDecimal
  volume_lte: ETHEREUM_BigDecimal
  volume_in: [ETHEREUM_BigDecimal!]
  volume_not_in: [ETHEREUM_BigDecimal!]
  volumeETH: ETHEREUM_BigDecimal
  volumeETH_not: ETHEREUM_BigDecimal
  volumeETH_gt: ETHEREUM_BigDecimal
  volumeETH_lt: ETHEREUM_BigDecimal
  volumeETH_gte: ETHEREUM_BigDecimal
  volumeETH_lte: ETHEREUM_BigDecimal
  volumeETH_in: [ETHEREUM_BigDecimal!]
  volumeETH_not_in: [ETHEREUM_BigDecimal!]
  volumeUSD: ETHEREUM_BigDecimal
  volumeUSD_not: ETHEREUM_BigDecimal
  volumeUSD_gt: ETHEREUM_BigDecimal
  volumeUSD_lt: ETHEREUM_BigDecimal
  volumeUSD_gte: ETHEREUM_BigDecimal
  volumeUSD_lte: ETHEREUM_BigDecimal
  volumeUSD_in: [ETHEREUM_BigDecimal!]
  volumeUSD_not_in: [ETHEREUM_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidity: ETHEREUM_BigDecimal
  liquidity_not: ETHEREUM_BigDecimal
  liquidity_gt: ETHEREUM_BigDecimal
  liquidity_lt: ETHEREUM_BigDecimal
  liquidity_gte: ETHEREUM_BigDecimal
  liquidity_lte: ETHEREUM_BigDecimal
  liquidity_in: [ETHEREUM_BigDecimal!]
  liquidity_not_in: [ETHEREUM_BigDecimal!]
  liquidityETH: ETHEREUM_BigDecimal
  liquidityETH_not: ETHEREUM_BigDecimal
  liquidityETH_gt: ETHEREUM_BigDecimal
  liquidityETH_lt: ETHEREUM_BigDecimal
  liquidityETH_gte: ETHEREUM_BigDecimal
  liquidityETH_lte: ETHEREUM_BigDecimal
  liquidityETH_in: [ETHEREUM_BigDecimal!]
  liquidityETH_not_in: [ETHEREUM_BigDecimal!]
  liquidityUSD: ETHEREUM_BigDecimal
  liquidityUSD_not: ETHEREUM_BigDecimal
  liquidityUSD_gt: ETHEREUM_BigDecimal
  liquidityUSD_lt: ETHEREUM_BigDecimal
  liquidityUSD_gte: ETHEREUM_BigDecimal
  liquidityUSD_lte: ETHEREUM_BigDecimal
  liquidityUSD_in: [ETHEREUM_BigDecimal!]
  liquidityUSD_not_in: [ETHEREUM_BigDecimal!]
  priceUSD: ETHEREUM_BigDecimal
  priceUSD_not: ETHEREUM_BigDecimal
  priceUSD_gt: ETHEREUM_BigDecimal
  priceUSD_lt: ETHEREUM_BigDecimal
  priceUSD_gte: ETHEREUM_BigDecimal
  priceUSD_lte: ETHEREUM_BigDecimal
  priceUSD_in: [ETHEREUM_BigDecimal!]
  priceUSD_not_in: [ETHEREUM_BigDecimal!]
}

enum ETHEREUM_TokenHourData_orderBy {
  id
  date
  token
  volume
  volumeETH
  volumeUSD
  txCount
  liquidity
  liquidityETH
  liquidityUSD
  priceUSD
}

type ETHEREUM_Transaction {
  id: ID!
  blockNumber: BigInt!
  timestamp: BigInt!
  mints(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Mint_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Mint_filter): [ETHEREUM_Mint]!
  burns(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Burn_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Burn_filter): [ETHEREUM_Burn]!
  swaps(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_Swap_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_Swap_filter): [ETHEREUM_Swap]!
}

input ETHEREUM_Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  mints: [String!]
  mints_not: [String!]
  mints_contains: [String!]
  mints_contains_nocase: [String!]
  mints_not_contains: [String!]
  mints_not_contains_nocase: [String!]
  burns: [String!]
  burns_not: [String!]
  burns_contains: [String!]
  burns_contains_nocase: [String!]
  burns_not_contains: [String!]
  burns_not_contains_nocase: [String!]
  swaps: [String!]
  swaps_not: [String!]
  swaps_contains: [String!]
  swaps_contains_nocase: [String!]
  swaps_not_contains: [String!]
  swaps_not_contains_nocase: [String!]
}

enum ETHEREUM_Transaction_orderBy {
  id
  blockNumber
  timestamp
  mints
  burns
  swaps
}

type ETHEREUM_User {
  id: ID!
  liquidityPositions(skip: Int = 0, first: Int = 100, orderBy: ETHEREUM_LiquidityPosition_orderBy, orderDirection: ETHEREUM_OrderDirection, where: ETHEREUM_LiquidityPosition_filter): [ETHEREUM_LiquidityPosition!]!
}

input ETHEREUM_User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
}

enum ETHEREUM_User_orderBy {
  id
  liquidityPositions
}

type MATIC__Block_ {
  """The hash of the block"""
  hash: MATIC_Bytes

  """The block number"""
  number: Int!
}

"""The type for the top-level _meta field"""
type MATIC__Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: MATIC__Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

scalar MATIC_BigDecimal

"""The block at which the query should be executed."""
input MATIC_Block_height {
  """Value containing a block hash"""
  hash: MATIC_Bytes

  """Value containing a block number"""
  number: Int

  """
  Value containing the minimum block number. 
  In the case of `number_gte`, the query will be executed on the latest block only if
  the subgraph has progressed to or past the minimum block number.
  Defaults to the latest block when omitted.
  
  """
  number_gte: Int
}

type MATIC_Bundle {
  id: ID!
  ethPrice: MATIC_BigDecimal!
}

input MATIC_Bundle_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  ethPrice: MATIC_BigDecimal
  ethPrice_not: MATIC_BigDecimal
  ethPrice_gt: MATIC_BigDecimal
  ethPrice_lt: MATIC_BigDecimal
  ethPrice_gte: MATIC_BigDecimal
  ethPrice_lte: MATIC_BigDecimal
  ethPrice_in: [MATIC_BigDecimal!]
  ethPrice_not_in: [MATIC_BigDecimal!]
}

enum MATIC_Bundle_orderBy {
  id
  ethPrice
}

type MATIC_Burn {
  id: ID!
  transaction: MATIC_Transaction!
  timestamp: BigInt!
  pair: MATIC_Pair!
  liquidity: MATIC_BigDecimal!
  sender: MATIC_Bytes
  amount0: MATIC_BigDecimal
  amount1: MATIC_BigDecimal
  to: MATIC_Bytes
  logIndex: BigInt
  amountUSD: MATIC_BigDecimal
  complete: Boolean!
  feeTo: MATIC_Bytes
  feeLiquidity: MATIC_BigDecimal
}

input MATIC_Burn_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  liquidity: MATIC_BigDecimal
  liquidity_not: MATIC_BigDecimal
  liquidity_gt: MATIC_BigDecimal
  liquidity_lt: MATIC_BigDecimal
  liquidity_gte: MATIC_BigDecimal
  liquidity_lte: MATIC_BigDecimal
  liquidity_in: [MATIC_BigDecimal!]
  liquidity_not_in: [MATIC_BigDecimal!]
  sender: MATIC_Bytes
  sender_not: MATIC_Bytes
  sender_in: [MATIC_Bytes!]
  sender_not_in: [MATIC_Bytes!]
  sender_contains: MATIC_Bytes
  sender_not_contains: MATIC_Bytes
  amount0: MATIC_BigDecimal
  amount0_not: MATIC_BigDecimal
  amount0_gt: MATIC_BigDecimal
  amount0_lt: MATIC_BigDecimal
  amount0_gte: MATIC_BigDecimal
  amount0_lte: MATIC_BigDecimal
  amount0_in: [MATIC_BigDecimal!]
  amount0_not_in: [MATIC_BigDecimal!]
  amount1: MATIC_BigDecimal
  amount1_not: MATIC_BigDecimal
  amount1_gt: MATIC_BigDecimal
  amount1_lt: MATIC_BigDecimal
  amount1_gte: MATIC_BigDecimal
  amount1_lte: MATIC_BigDecimal
  amount1_in: [MATIC_BigDecimal!]
  amount1_not_in: [MATIC_BigDecimal!]
  to: MATIC_Bytes
  to_not: MATIC_Bytes
  to_in: [MATIC_Bytes!]
  to_not_in: [MATIC_Bytes!]
  to_contains: MATIC_Bytes
  to_not_contains: MATIC_Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  amountUSD: MATIC_BigDecimal
  amountUSD_not: MATIC_BigDecimal
  amountUSD_gt: MATIC_BigDecimal
  amountUSD_lt: MATIC_BigDecimal
  amountUSD_gte: MATIC_BigDecimal
  amountUSD_lte: MATIC_BigDecimal
  amountUSD_in: [MATIC_BigDecimal!]
  amountUSD_not_in: [MATIC_BigDecimal!]
  complete: Boolean
  complete_not: Boolean
  complete_in: [Boolean!]
  complete_not_in: [Boolean!]
  feeTo: MATIC_Bytes
  feeTo_not: MATIC_Bytes
  feeTo_in: [MATIC_Bytes!]
  feeTo_not_in: [MATIC_Bytes!]
  feeTo_contains: MATIC_Bytes
  feeTo_not_contains: MATIC_Bytes
  feeLiquidity: MATIC_BigDecimal
  feeLiquidity_not: MATIC_BigDecimal
  feeLiquidity_gt: MATIC_BigDecimal
  feeLiquidity_lt: MATIC_BigDecimal
  feeLiquidity_gte: MATIC_BigDecimal
  feeLiquidity_lte: MATIC_BigDecimal
  feeLiquidity_in: [MATIC_BigDecimal!]
  feeLiquidity_not_in: [MATIC_BigDecimal!]
}

enum MATIC_Burn_orderBy {
  id
  transaction
  timestamp
  pair
  liquidity
  sender
  amount0
  amount1
  to
  logIndex
  amountUSD
  complete
  feeTo
  feeLiquidity
}

scalar MATIC_Bytes

type MATIC_DayData {
  id: ID!
  date: Int!
  factory: MATIC_Factory!
  volumeETH: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  untrackedVolume: MATIC_BigDecimal!
  liquidityETH: MATIC_BigDecimal!
  liquidityUSD: MATIC_BigDecimal!
  txCount: BigInt!
}

input MATIC_DayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  volumeETH: MATIC_BigDecimal
  volumeETH_not: MATIC_BigDecimal
  volumeETH_gt: MATIC_BigDecimal
  volumeETH_lt: MATIC_BigDecimal
  volumeETH_gte: MATIC_BigDecimal
  volumeETH_lte: MATIC_BigDecimal
  volumeETH_in: [MATIC_BigDecimal!]
  volumeETH_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  untrackedVolume: MATIC_BigDecimal
  untrackedVolume_not: MATIC_BigDecimal
  untrackedVolume_gt: MATIC_BigDecimal
  untrackedVolume_lt: MATIC_BigDecimal
  untrackedVolume_gte: MATIC_BigDecimal
  untrackedVolume_lte: MATIC_BigDecimal
  untrackedVolume_in: [MATIC_BigDecimal!]
  untrackedVolume_not_in: [MATIC_BigDecimal!]
  liquidityETH: MATIC_BigDecimal
  liquidityETH_not: MATIC_BigDecimal
  liquidityETH_gt: MATIC_BigDecimal
  liquidityETH_lt: MATIC_BigDecimal
  liquidityETH_gte: MATIC_BigDecimal
  liquidityETH_lte: MATIC_BigDecimal
  liquidityETH_in: [MATIC_BigDecimal!]
  liquidityETH_not_in: [MATIC_BigDecimal!]
  liquidityUSD: MATIC_BigDecimal
  liquidityUSD_not: MATIC_BigDecimal
  liquidityUSD_gt: MATIC_BigDecimal
  liquidityUSD_lt: MATIC_BigDecimal
  liquidityUSD_gte: MATIC_BigDecimal
  liquidityUSD_lte: MATIC_BigDecimal
  liquidityUSD_in: [MATIC_BigDecimal!]
  liquidityUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum MATIC_DayData_orderBy {
  id
  date
  factory
  volumeETH
  volumeUSD
  untrackedVolume
  liquidityETH
  liquidityUSD
  txCount
}

type MATIC_Factory {
  id: ID!
  pairCount: BigInt!
  volumeUSD: MATIC_BigDecimal!
  volumeETH: MATIC_BigDecimal!
  untrackedVolumeUSD: MATIC_BigDecimal!
  liquidityUSD: MATIC_BigDecimal!
  liquidityETH: MATIC_BigDecimal!
  txCount: BigInt!
  tokenCount: BigInt!
  userCount: BigInt!
  pairs(skip: Int = 0, first: Int = 100, orderBy: MATIC_Pair_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Pair_filter): [MATIC_Pair!]!
  tokens(skip: Int = 0, first: Int = 100, orderBy: MATIC_Token_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Token_filter): [MATIC_Token!]!
  hourData(skip: Int = 0, first: Int = 100, orderBy: MATIC_HourData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_HourData_filter): [MATIC_HourData!]!
  dayData(skip: Int = 0, first: Int = 100, orderBy: MATIC_DayData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_DayData_filter): [MATIC_DayData!]!
}

input MATIC_Factory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  pairCount: BigInt
  pairCount_not: BigInt
  pairCount_gt: BigInt
  pairCount_lt: BigInt
  pairCount_gte: BigInt
  pairCount_lte: BigInt
  pairCount_in: [BigInt!]
  pairCount_not_in: [BigInt!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  volumeETH: MATIC_BigDecimal
  volumeETH_not: MATIC_BigDecimal
  volumeETH_gt: MATIC_BigDecimal
  volumeETH_lt: MATIC_BigDecimal
  volumeETH_gte: MATIC_BigDecimal
  volumeETH_lte: MATIC_BigDecimal
  volumeETH_in: [MATIC_BigDecimal!]
  volumeETH_not_in: [MATIC_BigDecimal!]
  untrackedVolumeUSD: MATIC_BigDecimal
  untrackedVolumeUSD_not: MATIC_BigDecimal
  untrackedVolumeUSD_gt: MATIC_BigDecimal
  untrackedVolumeUSD_lt: MATIC_BigDecimal
  untrackedVolumeUSD_gte: MATIC_BigDecimal
  untrackedVolumeUSD_lte: MATIC_BigDecimal
  untrackedVolumeUSD_in: [MATIC_BigDecimal!]
  untrackedVolumeUSD_not_in: [MATIC_BigDecimal!]
  liquidityUSD: MATIC_BigDecimal
  liquidityUSD_not: MATIC_BigDecimal
  liquidityUSD_gt: MATIC_BigDecimal
  liquidityUSD_lt: MATIC_BigDecimal
  liquidityUSD_gte: MATIC_BigDecimal
  liquidityUSD_lte: MATIC_BigDecimal
  liquidityUSD_in: [MATIC_BigDecimal!]
  liquidityUSD_not_in: [MATIC_BigDecimal!]
  liquidityETH: MATIC_BigDecimal
  liquidityETH_not: MATIC_BigDecimal
  liquidityETH_gt: MATIC_BigDecimal
  liquidityETH_lt: MATIC_BigDecimal
  liquidityETH_gte: MATIC_BigDecimal
  liquidityETH_lte: MATIC_BigDecimal
  liquidityETH_in: [MATIC_BigDecimal!]
  liquidityETH_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  tokenCount: BigInt
  tokenCount_not: BigInt
  tokenCount_gt: BigInt
  tokenCount_lt: BigInt
  tokenCount_gte: BigInt
  tokenCount_lte: BigInt
  tokenCount_in: [BigInt!]
  tokenCount_not_in: [BigInt!]
  userCount: BigInt
  userCount_not: BigInt
  userCount_gt: BigInt
  userCount_lt: BigInt
  userCount_gte: BigInt
  userCount_lte: BigInt
  userCount_in: [BigInt!]
  userCount_not_in: [BigInt!]
}

enum MATIC_Factory_orderBy {
  id
  pairCount
  volumeUSD
  volumeETH
  untrackedVolumeUSD
  liquidityUSD
  liquidityETH
  txCount
  tokenCount
  userCount
  pairs
  tokens
  hourData
  dayData
}

type MATIC_HourData {
  id: ID!
  date: Int!
  factory: MATIC_Factory!
  volumeETH: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  untrackedVolume: MATIC_BigDecimal!
  liquidityETH: MATIC_BigDecimal!
  liquidityUSD: MATIC_BigDecimal!
  txCount: BigInt!
}

input MATIC_HourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  volumeETH: MATIC_BigDecimal
  volumeETH_not: MATIC_BigDecimal
  volumeETH_gt: MATIC_BigDecimal
  volumeETH_lt: MATIC_BigDecimal
  volumeETH_gte: MATIC_BigDecimal
  volumeETH_lte: MATIC_BigDecimal
  volumeETH_in: [MATIC_BigDecimal!]
  volumeETH_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  untrackedVolume: MATIC_BigDecimal
  untrackedVolume_not: MATIC_BigDecimal
  untrackedVolume_gt: MATIC_BigDecimal
  untrackedVolume_lt: MATIC_BigDecimal
  untrackedVolume_gte: MATIC_BigDecimal
  untrackedVolume_lte: MATIC_BigDecimal
  untrackedVolume_in: [MATIC_BigDecimal!]
  untrackedVolume_not_in: [MATIC_BigDecimal!]
  liquidityETH: MATIC_BigDecimal
  liquidityETH_not: MATIC_BigDecimal
  liquidityETH_gt: MATIC_BigDecimal
  liquidityETH_lt: MATIC_BigDecimal
  liquidityETH_gte: MATIC_BigDecimal
  liquidityETH_lte: MATIC_BigDecimal
  liquidityETH_in: [MATIC_BigDecimal!]
  liquidityETH_not_in: [MATIC_BigDecimal!]
  liquidityUSD: MATIC_BigDecimal
  liquidityUSD_not: MATIC_BigDecimal
  liquidityUSD_gt: MATIC_BigDecimal
  liquidityUSD_lt: MATIC_BigDecimal
  liquidityUSD_gte: MATIC_BigDecimal
  liquidityUSD_lte: MATIC_BigDecimal
  liquidityUSD_in: [MATIC_BigDecimal!]
  liquidityUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum MATIC_HourData_orderBy {
  id
  date
  factory
  volumeETH
  volumeUSD
  untrackedVolume
  liquidityETH
  liquidityUSD
  txCount
}

type MATIC_LiquidityPosition {
  id: ID!
  user: MATIC_User!
  pair: MATIC_Pair!
  liquidityTokenBalance: MATIC_BigDecimal!
  snapshots(skip: Int = 0, first: Int = 100, orderBy: MATIC_LiquidityPositionSnapshot_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_LiquidityPositionSnapshot_filter): [MATIC_LiquidityPositionSnapshot]!
  block: Int!
  timestamp: Int!
}

input MATIC_LiquidityPosition_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  liquidityTokenBalance: MATIC_BigDecimal
  liquidityTokenBalance_not: MATIC_BigDecimal
  liquidityTokenBalance_gt: MATIC_BigDecimal
  liquidityTokenBalance_lt: MATIC_BigDecimal
  liquidityTokenBalance_gte: MATIC_BigDecimal
  liquidityTokenBalance_lte: MATIC_BigDecimal
  liquidityTokenBalance_in: [MATIC_BigDecimal!]
  liquidityTokenBalance_not_in: [MATIC_BigDecimal!]
  block: Int
  block_not: Int
  block_gt: Int
  block_lt: Int
  block_gte: Int
  block_lte: Int
  block_in: [Int!]
  block_not_in: [Int!]
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
}

enum MATIC_LiquidityPosition_orderBy {
  id
  user
  pair
  liquidityTokenBalance
  snapshots
  block
  timestamp
}

type MATIC_LiquidityPositionSnapshot {
  id: ID!
  liquidityPosition: MATIC_LiquidityPosition!
  timestamp: Int!
  block: Int!
  user: MATIC_User!
  pair: MATIC_Pair!
  token0PriceUSD: MATIC_BigDecimal!
  token1PriceUSD: MATIC_BigDecimal!
  reserve0: MATIC_BigDecimal!
  reserve1: MATIC_BigDecimal!
  reserveUSD: MATIC_BigDecimal!
  liquidityTokenTotalSupply: MATIC_BigDecimal!
  liquidityTokenBalance: MATIC_BigDecimal!
}

input MATIC_LiquidityPositionSnapshot_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  liquidityPosition: String
  liquidityPosition_not: String
  liquidityPosition_gt: String
  liquidityPosition_lt: String
  liquidityPosition_gte: String
  liquidityPosition_lte: String
  liquidityPosition_in: [String!]
  liquidityPosition_not_in: [String!]
  liquidityPosition_contains: String
  liquidityPosition_contains_nocase: String
  liquidityPosition_not_contains: String
  liquidityPosition_not_contains_nocase: String
  liquidityPosition_starts_with: String
  liquidityPosition_starts_with_nocase: String
  liquidityPosition_not_starts_with: String
  liquidityPosition_not_starts_with_nocase: String
  liquidityPosition_ends_with: String
  liquidityPosition_ends_with_nocase: String
  liquidityPosition_not_ends_with: String
  liquidityPosition_not_ends_with_nocase: String
  timestamp: Int
  timestamp_not: Int
  timestamp_gt: Int
  timestamp_lt: Int
  timestamp_gte: Int
  timestamp_lte: Int
  timestamp_in: [Int!]
  timestamp_not_in: [Int!]
  block: Int
  block_not: Int
  block_gt: Int
  block_lt: Int
  block_gte: Int
  block_lte: Int
  block_in: [Int!]
  block_not_in: [Int!]
  user: String
  user_not: String
  user_gt: String
  user_lt: String
  user_gte: String
  user_lte: String
  user_in: [String!]
  user_not_in: [String!]
  user_contains: String
  user_contains_nocase: String
  user_not_contains: String
  user_not_contains_nocase: String
  user_starts_with: String
  user_starts_with_nocase: String
  user_not_starts_with: String
  user_not_starts_with_nocase: String
  user_ends_with: String
  user_ends_with_nocase: String
  user_not_ends_with: String
  user_not_ends_with_nocase: String
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  token0PriceUSD: MATIC_BigDecimal
  token0PriceUSD_not: MATIC_BigDecimal
  token0PriceUSD_gt: MATIC_BigDecimal
  token0PriceUSD_lt: MATIC_BigDecimal
  token0PriceUSD_gte: MATIC_BigDecimal
  token0PriceUSD_lte: MATIC_BigDecimal
  token0PriceUSD_in: [MATIC_BigDecimal!]
  token0PriceUSD_not_in: [MATIC_BigDecimal!]
  token1PriceUSD: MATIC_BigDecimal
  token1PriceUSD_not: MATIC_BigDecimal
  token1PriceUSD_gt: MATIC_BigDecimal
  token1PriceUSD_lt: MATIC_BigDecimal
  token1PriceUSD_gte: MATIC_BigDecimal
  token1PriceUSD_lte: MATIC_BigDecimal
  token1PriceUSD_in: [MATIC_BigDecimal!]
  token1PriceUSD_not_in: [MATIC_BigDecimal!]
  reserve0: MATIC_BigDecimal
  reserve0_not: MATIC_BigDecimal
  reserve0_gt: MATIC_BigDecimal
  reserve0_lt: MATIC_BigDecimal
  reserve0_gte: MATIC_BigDecimal
  reserve0_lte: MATIC_BigDecimal
  reserve0_in: [MATIC_BigDecimal!]
  reserve0_not_in: [MATIC_BigDecimal!]
  reserve1: MATIC_BigDecimal
  reserve1_not: MATIC_BigDecimal
  reserve1_gt: MATIC_BigDecimal
  reserve1_lt: MATIC_BigDecimal
  reserve1_gte: MATIC_BigDecimal
  reserve1_lte: MATIC_BigDecimal
  reserve1_in: [MATIC_BigDecimal!]
  reserve1_not_in: [MATIC_BigDecimal!]
  reserveUSD: MATIC_BigDecimal
  reserveUSD_not: MATIC_BigDecimal
  reserveUSD_gt: MATIC_BigDecimal
  reserveUSD_lt: MATIC_BigDecimal
  reserveUSD_gte: MATIC_BigDecimal
  reserveUSD_lte: MATIC_BigDecimal
  reserveUSD_in: [MATIC_BigDecimal!]
  reserveUSD_not_in: [MATIC_BigDecimal!]
  liquidityTokenTotalSupply: MATIC_BigDecimal
  liquidityTokenTotalSupply_not: MATIC_BigDecimal
  liquidityTokenTotalSupply_gt: MATIC_BigDecimal
  liquidityTokenTotalSupply_lt: MATIC_BigDecimal
  liquidityTokenTotalSupply_gte: MATIC_BigDecimal
  liquidityTokenTotalSupply_lte: MATIC_BigDecimal
  liquidityTokenTotalSupply_in: [MATIC_BigDecimal!]
  liquidityTokenTotalSupply_not_in: [MATIC_BigDecimal!]
  liquidityTokenBalance: MATIC_BigDecimal
  liquidityTokenBalance_not: MATIC_BigDecimal
  liquidityTokenBalance_gt: MATIC_BigDecimal
  liquidityTokenBalance_lt: MATIC_BigDecimal
  liquidityTokenBalance_gte: MATIC_BigDecimal
  liquidityTokenBalance_lte: MATIC_BigDecimal
  liquidityTokenBalance_in: [MATIC_BigDecimal!]
  liquidityTokenBalance_not_in: [MATIC_BigDecimal!]
}

enum MATIC_LiquidityPositionSnapshot_orderBy {
  id
  liquidityPosition
  timestamp
  block
  user
  pair
  token0PriceUSD
  token1PriceUSD
  reserve0
  reserve1
  reserveUSD
  liquidityTokenTotalSupply
  liquidityTokenBalance
}

type MATIC_Mint {
  id: ID!
  transaction: MATIC_Transaction!
  timestamp: BigInt!
  pair: MATIC_Pair!
  to: MATIC_Bytes!
  liquidity: MATIC_BigDecimal!
  sender: MATIC_Bytes
  amount0: MATIC_BigDecimal
  amount1: MATIC_BigDecimal
  logIndex: BigInt
  amountUSD: MATIC_BigDecimal
  feeTo: MATIC_Bytes
  feeLiquidity: MATIC_BigDecimal
}

input MATIC_Mint_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  to: MATIC_Bytes
  to_not: MATIC_Bytes
  to_in: [MATIC_Bytes!]
  to_not_in: [MATIC_Bytes!]
  to_contains: MATIC_Bytes
  to_not_contains: MATIC_Bytes
  liquidity: MATIC_BigDecimal
  liquidity_not: MATIC_BigDecimal
  liquidity_gt: MATIC_BigDecimal
  liquidity_lt: MATIC_BigDecimal
  liquidity_gte: MATIC_BigDecimal
  liquidity_lte: MATIC_BigDecimal
  liquidity_in: [MATIC_BigDecimal!]
  liquidity_not_in: [MATIC_BigDecimal!]
  sender: MATIC_Bytes
  sender_not: MATIC_Bytes
  sender_in: [MATIC_Bytes!]
  sender_not_in: [MATIC_Bytes!]
  sender_contains: MATIC_Bytes
  sender_not_contains: MATIC_Bytes
  amount0: MATIC_BigDecimal
  amount0_not: MATIC_BigDecimal
  amount0_gt: MATIC_BigDecimal
  amount0_lt: MATIC_BigDecimal
  amount0_gte: MATIC_BigDecimal
  amount0_lte: MATIC_BigDecimal
  amount0_in: [MATIC_BigDecimal!]
  amount0_not_in: [MATIC_BigDecimal!]
  amount1: MATIC_BigDecimal
  amount1_not: MATIC_BigDecimal
  amount1_gt: MATIC_BigDecimal
  amount1_lt: MATIC_BigDecimal
  amount1_gte: MATIC_BigDecimal
  amount1_lte: MATIC_BigDecimal
  amount1_in: [MATIC_BigDecimal!]
  amount1_not_in: [MATIC_BigDecimal!]
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  amountUSD: MATIC_BigDecimal
  amountUSD_not: MATIC_BigDecimal
  amountUSD_gt: MATIC_BigDecimal
  amountUSD_lt: MATIC_BigDecimal
  amountUSD_gte: MATIC_BigDecimal
  amountUSD_lte: MATIC_BigDecimal
  amountUSD_in: [MATIC_BigDecimal!]
  amountUSD_not_in: [MATIC_BigDecimal!]
  feeTo: MATIC_Bytes
  feeTo_not: MATIC_Bytes
  feeTo_in: [MATIC_Bytes!]
  feeTo_not_in: [MATIC_Bytes!]
  feeTo_contains: MATIC_Bytes
  feeTo_not_contains: MATIC_Bytes
  feeLiquidity: MATIC_BigDecimal
  feeLiquidity_not: MATIC_BigDecimal
  feeLiquidity_gt: MATIC_BigDecimal
  feeLiquidity_lt: MATIC_BigDecimal
  feeLiquidity_gte: MATIC_BigDecimal
  feeLiquidity_lte: MATIC_BigDecimal
  feeLiquidity_in: [MATIC_BigDecimal!]
  feeLiquidity_not_in: [MATIC_BigDecimal!]
}

enum MATIC_Mint_orderBy {
  id
  transaction
  timestamp
  pair
  to
  liquidity
  sender
  amount0
  amount1
  logIndex
  amountUSD
  feeTo
  feeLiquidity
}

"""Defines the order direction, either ascending or descending"""
enum MATIC_OrderDirection {
  asc
  desc
}

type MATIC_Pair {
  id: ID!
  factory: MATIC_Factory!
  name: String!
  token0: MATIC_Token!
  token1: MATIC_Token!
  reserve0: MATIC_BigDecimal!
  reserve1: MATIC_BigDecimal!
  totalSupply: MATIC_BigDecimal!
  reserveETH: MATIC_BigDecimal!
  reserveUSD: MATIC_BigDecimal!
  trackedReserveETH: MATIC_BigDecimal!
  token0Price: MATIC_BigDecimal!
  token1Price: MATIC_BigDecimal!
  volumeToken0: MATIC_BigDecimal!
  volumeToken1: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  untrackedVolumeUSD: MATIC_BigDecimal!
  txCount: BigInt!
  liquidityProviderCount: BigInt!
  liquidityPositions(skip: Int = 0, first: Int = 100, orderBy: MATIC_LiquidityPosition_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_LiquidityPosition_filter): [MATIC_LiquidityPosition!]!
  liquidityPositionSnapshots(skip: Int = 0, first: Int = 100, orderBy: MATIC_LiquidityPositionSnapshot_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_LiquidityPositionSnapshot_filter): [MATIC_LiquidityPositionSnapshot!]!
  dayData(skip: Int = 0, first: Int = 100, orderBy: MATIC_PairDayData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_PairDayData_filter): [MATIC_PairDayData!]!
  hourData(skip: Int = 0, first: Int = 100, orderBy: MATIC_PairHourData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_PairHourData_filter): [MATIC_PairHourData!]!
  mints(skip: Int = 0, first: Int = 100, orderBy: MATIC_Mint_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Mint_filter): [MATIC_Mint!]!
  burns(skip: Int = 0, first: Int = 100, orderBy: MATIC_Burn_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Burn_filter): [MATIC_Burn!]!
  swaps(skip: Int = 0, first: Int = 100, orderBy: MATIC_Swap_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Swap_filter): [MATIC_Swap!]!
  timestamp: BigInt!
  block: BigInt!
}

input MATIC_Pair_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  reserve0: MATIC_BigDecimal
  reserve0_not: MATIC_BigDecimal
  reserve0_gt: MATIC_BigDecimal
  reserve0_lt: MATIC_BigDecimal
  reserve0_gte: MATIC_BigDecimal
  reserve0_lte: MATIC_BigDecimal
  reserve0_in: [MATIC_BigDecimal!]
  reserve0_not_in: [MATIC_BigDecimal!]
  reserve1: MATIC_BigDecimal
  reserve1_not: MATIC_BigDecimal
  reserve1_gt: MATIC_BigDecimal
  reserve1_lt: MATIC_BigDecimal
  reserve1_gte: MATIC_BigDecimal
  reserve1_lte: MATIC_BigDecimal
  reserve1_in: [MATIC_BigDecimal!]
  reserve1_not_in: [MATIC_BigDecimal!]
  totalSupply: MATIC_BigDecimal
  totalSupply_not: MATIC_BigDecimal
  totalSupply_gt: MATIC_BigDecimal
  totalSupply_lt: MATIC_BigDecimal
  totalSupply_gte: MATIC_BigDecimal
  totalSupply_lte: MATIC_BigDecimal
  totalSupply_in: [MATIC_BigDecimal!]
  totalSupply_not_in: [MATIC_BigDecimal!]
  reserveETH: MATIC_BigDecimal
  reserveETH_not: MATIC_BigDecimal
  reserveETH_gt: MATIC_BigDecimal
  reserveETH_lt: MATIC_BigDecimal
  reserveETH_gte: MATIC_BigDecimal
  reserveETH_lte: MATIC_BigDecimal
  reserveETH_in: [MATIC_BigDecimal!]
  reserveETH_not_in: [MATIC_BigDecimal!]
  reserveUSD: MATIC_BigDecimal
  reserveUSD_not: MATIC_BigDecimal
  reserveUSD_gt: MATIC_BigDecimal
  reserveUSD_lt: MATIC_BigDecimal
  reserveUSD_gte: MATIC_BigDecimal
  reserveUSD_lte: MATIC_BigDecimal
  reserveUSD_in: [MATIC_BigDecimal!]
  reserveUSD_not_in: [MATIC_BigDecimal!]
  trackedReserveETH: MATIC_BigDecimal
  trackedReserveETH_not: MATIC_BigDecimal
  trackedReserveETH_gt: MATIC_BigDecimal
  trackedReserveETH_lt: MATIC_BigDecimal
  trackedReserveETH_gte: MATIC_BigDecimal
  trackedReserveETH_lte: MATIC_BigDecimal
  trackedReserveETH_in: [MATIC_BigDecimal!]
  trackedReserveETH_not_in: [MATIC_BigDecimal!]
  token0Price: MATIC_BigDecimal
  token0Price_not: MATIC_BigDecimal
  token0Price_gt: MATIC_BigDecimal
  token0Price_lt: MATIC_BigDecimal
  token0Price_gte: MATIC_BigDecimal
  token0Price_lte: MATIC_BigDecimal
  token0Price_in: [MATIC_BigDecimal!]
  token0Price_not_in: [MATIC_BigDecimal!]
  token1Price: MATIC_BigDecimal
  token1Price_not: MATIC_BigDecimal
  token1Price_gt: MATIC_BigDecimal
  token1Price_lt: MATIC_BigDecimal
  token1Price_gte: MATIC_BigDecimal
  token1Price_lte: MATIC_BigDecimal
  token1Price_in: [MATIC_BigDecimal!]
  token1Price_not_in: [MATIC_BigDecimal!]
  volumeToken0: MATIC_BigDecimal
  volumeToken0_not: MATIC_BigDecimal
  volumeToken0_gt: MATIC_BigDecimal
  volumeToken0_lt: MATIC_BigDecimal
  volumeToken0_gte: MATIC_BigDecimal
  volumeToken0_lte: MATIC_BigDecimal
  volumeToken0_in: [MATIC_BigDecimal!]
  volumeToken0_not_in: [MATIC_BigDecimal!]
  volumeToken1: MATIC_BigDecimal
  volumeToken1_not: MATIC_BigDecimal
  volumeToken1_gt: MATIC_BigDecimal
  volumeToken1_lt: MATIC_BigDecimal
  volumeToken1_gte: MATIC_BigDecimal
  volumeToken1_lte: MATIC_BigDecimal
  volumeToken1_in: [MATIC_BigDecimal!]
  volumeToken1_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  untrackedVolumeUSD: MATIC_BigDecimal
  untrackedVolumeUSD_not: MATIC_BigDecimal
  untrackedVolumeUSD_gt: MATIC_BigDecimal
  untrackedVolumeUSD_lt: MATIC_BigDecimal
  untrackedVolumeUSD_gte: MATIC_BigDecimal
  untrackedVolumeUSD_lte: MATIC_BigDecimal
  untrackedVolumeUSD_in: [MATIC_BigDecimal!]
  untrackedVolumeUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidityProviderCount: BigInt
  liquidityProviderCount_not: BigInt
  liquidityProviderCount_gt: BigInt
  liquidityProviderCount_lt: BigInt
  liquidityProviderCount_gte: BigInt
  liquidityProviderCount_lte: BigInt
  liquidityProviderCount_in: [BigInt!]
  liquidityProviderCount_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  block: BigInt
  block_not: BigInt
  block_gt: BigInt
  block_lt: BigInt
  block_gte: BigInt
  block_lte: BigInt
  block_in: [BigInt!]
  block_not_in: [BigInt!]
}

enum MATIC_Pair_orderBy {
  id
  factory
  name
  token0
  token1
  reserve0
  reserve1
  totalSupply
  reserveETH
  reserveUSD
  trackedReserveETH
  token0Price
  token1Price
  volumeToken0
  volumeToken1
  volumeUSD
  untrackedVolumeUSD
  txCount
  liquidityProviderCount
  liquidityPositions
  liquidityPositionSnapshots
  dayData
  hourData
  mints
  burns
  swaps
  timestamp
  block
}

type MATIC_PairDayData {
  id: ID!
  date: Int!
  pair: MATIC_Pair!
  token0: MATIC_Token!
  token1: MATIC_Token!
  reserve0: MATIC_BigDecimal!
  reserve1: MATIC_BigDecimal!
  totalSupply: MATIC_BigDecimal!
  reserveUSD: MATIC_BigDecimal!
  volumeToken0: MATIC_BigDecimal!
  volumeToken1: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  txCount: BigInt!
}

input MATIC_PairDayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  token0: String
  token0_not: String
  token0_gt: String
  token0_lt: String
  token0_gte: String
  token0_lte: String
  token0_in: [String!]
  token0_not_in: [String!]
  token0_contains: String
  token0_contains_nocase: String
  token0_not_contains: String
  token0_not_contains_nocase: String
  token0_starts_with: String
  token0_starts_with_nocase: String
  token0_not_starts_with: String
  token0_not_starts_with_nocase: String
  token0_ends_with: String
  token0_ends_with_nocase: String
  token0_not_ends_with: String
  token0_not_ends_with_nocase: String
  token1: String
  token1_not: String
  token1_gt: String
  token1_lt: String
  token1_gte: String
  token1_lte: String
  token1_in: [String!]
  token1_not_in: [String!]
  token1_contains: String
  token1_contains_nocase: String
  token1_not_contains: String
  token1_not_contains_nocase: String
  token1_starts_with: String
  token1_starts_with_nocase: String
  token1_not_starts_with: String
  token1_not_starts_with_nocase: String
  token1_ends_with: String
  token1_ends_with_nocase: String
  token1_not_ends_with: String
  token1_not_ends_with_nocase: String
  reserve0: MATIC_BigDecimal
  reserve0_not: MATIC_BigDecimal
  reserve0_gt: MATIC_BigDecimal
  reserve0_lt: MATIC_BigDecimal
  reserve0_gte: MATIC_BigDecimal
  reserve0_lte: MATIC_BigDecimal
  reserve0_in: [MATIC_BigDecimal!]
  reserve0_not_in: [MATIC_BigDecimal!]
  reserve1: MATIC_BigDecimal
  reserve1_not: MATIC_BigDecimal
  reserve1_gt: MATIC_BigDecimal
  reserve1_lt: MATIC_BigDecimal
  reserve1_gte: MATIC_BigDecimal
  reserve1_lte: MATIC_BigDecimal
  reserve1_in: [MATIC_BigDecimal!]
  reserve1_not_in: [MATIC_BigDecimal!]
  totalSupply: MATIC_BigDecimal
  totalSupply_not: MATIC_BigDecimal
  totalSupply_gt: MATIC_BigDecimal
  totalSupply_lt: MATIC_BigDecimal
  totalSupply_gte: MATIC_BigDecimal
  totalSupply_lte: MATIC_BigDecimal
  totalSupply_in: [MATIC_BigDecimal!]
  totalSupply_not_in: [MATIC_BigDecimal!]
  reserveUSD: MATIC_BigDecimal
  reserveUSD_not: MATIC_BigDecimal
  reserveUSD_gt: MATIC_BigDecimal
  reserveUSD_lt: MATIC_BigDecimal
  reserveUSD_gte: MATIC_BigDecimal
  reserveUSD_lte: MATIC_BigDecimal
  reserveUSD_in: [MATIC_BigDecimal!]
  reserveUSD_not_in: [MATIC_BigDecimal!]
  volumeToken0: MATIC_BigDecimal
  volumeToken0_not: MATIC_BigDecimal
  volumeToken0_gt: MATIC_BigDecimal
  volumeToken0_lt: MATIC_BigDecimal
  volumeToken0_gte: MATIC_BigDecimal
  volumeToken0_lte: MATIC_BigDecimal
  volumeToken0_in: [MATIC_BigDecimal!]
  volumeToken0_not_in: [MATIC_BigDecimal!]
  volumeToken1: MATIC_BigDecimal
  volumeToken1_not: MATIC_BigDecimal
  volumeToken1_gt: MATIC_BigDecimal
  volumeToken1_lt: MATIC_BigDecimal
  volumeToken1_gte: MATIC_BigDecimal
  volumeToken1_lte: MATIC_BigDecimal
  volumeToken1_in: [MATIC_BigDecimal!]
  volumeToken1_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum MATIC_PairDayData_orderBy {
  id
  date
  pair
  token0
  token1
  reserve0
  reserve1
  totalSupply
  reserveUSD
  volumeToken0
  volumeToken1
  volumeUSD
  txCount
}

type MATIC_PairHourData {
  id: ID!
  date: Int!
  pair: MATIC_Pair!
  reserve0: MATIC_BigDecimal!
  reserve1: MATIC_BigDecimal!
  reserveUSD: MATIC_BigDecimal!
  volumeToken0: MATIC_BigDecimal!
  volumeToken1: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  txCount: BigInt!
}

input MATIC_PairHourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  reserve0: MATIC_BigDecimal
  reserve0_not: MATIC_BigDecimal
  reserve0_gt: MATIC_BigDecimal
  reserve0_lt: MATIC_BigDecimal
  reserve0_gte: MATIC_BigDecimal
  reserve0_lte: MATIC_BigDecimal
  reserve0_in: [MATIC_BigDecimal!]
  reserve0_not_in: [MATIC_BigDecimal!]
  reserve1: MATIC_BigDecimal
  reserve1_not: MATIC_BigDecimal
  reserve1_gt: MATIC_BigDecimal
  reserve1_lt: MATIC_BigDecimal
  reserve1_gte: MATIC_BigDecimal
  reserve1_lte: MATIC_BigDecimal
  reserve1_in: [MATIC_BigDecimal!]
  reserve1_not_in: [MATIC_BigDecimal!]
  reserveUSD: MATIC_BigDecimal
  reserveUSD_not: MATIC_BigDecimal
  reserveUSD_gt: MATIC_BigDecimal
  reserveUSD_lt: MATIC_BigDecimal
  reserveUSD_gte: MATIC_BigDecimal
  reserveUSD_lte: MATIC_BigDecimal
  reserveUSD_in: [MATIC_BigDecimal!]
  reserveUSD_not_in: [MATIC_BigDecimal!]
  volumeToken0: MATIC_BigDecimal
  volumeToken0_not: MATIC_BigDecimal
  volumeToken0_gt: MATIC_BigDecimal
  volumeToken0_lt: MATIC_BigDecimal
  volumeToken0_gte: MATIC_BigDecimal
  volumeToken0_lte: MATIC_BigDecimal
  volumeToken0_in: [MATIC_BigDecimal!]
  volumeToken0_not_in: [MATIC_BigDecimal!]
  volumeToken1: MATIC_BigDecimal
  volumeToken1_not: MATIC_BigDecimal
  volumeToken1_gt: MATIC_BigDecimal
  volumeToken1_lt: MATIC_BigDecimal
  volumeToken1_gte: MATIC_BigDecimal
  volumeToken1_lte: MATIC_BigDecimal
  volumeToken1_in: [MATIC_BigDecimal!]
  volumeToken1_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
}

enum MATIC_PairHourData_orderBy {
  id
  date
  pair
  reserve0
  reserve1
  reserveUSD
  volumeToken0
  volumeToken1
  volumeUSD
  txCount
}

type MATIC_Swap {
  id: ID!
  transaction: MATIC_Transaction!
  timestamp: BigInt!
  pair: MATIC_Pair!
  sender: MATIC_Bytes!
  amount0In: MATIC_BigDecimal!
  amount1In: MATIC_BigDecimal!
  amount0Out: MATIC_BigDecimal!
  amount1Out: MATIC_BigDecimal!
  to: MATIC_Bytes!
  logIndex: BigInt
  amountUSD: MATIC_BigDecimal!
}

input MATIC_Swap_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  transaction: String
  transaction_not: String
  transaction_gt: String
  transaction_lt: String
  transaction_gte: String
  transaction_lte: String
  transaction_in: [String!]
  transaction_not_in: [String!]
  transaction_contains: String
  transaction_contains_nocase: String
  transaction_not_contains: String
  transaction_not_contains_nocase: String
  transaction_starts_with: String
  transaction_starts_with_nocase: String
  transaction_not_starts_with: String
  transaction_not_starts_with_nocase: String
  transaction_ends_with: String
  transaction_ends_with_nocase: String
  transaction_not_ends_with: String
  transaction_not_ends_with_nocase: String
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  pair: String
  pair_not: String
  pair_gt: String
  pair_lt: String
  pair_gte: String
  pair_lte: String
  pair_in: [String!]
  pair_not_in: [String!]
  pair_contains: String
  pair_contains_nocase: String
  pair_not_contains: String
  pair_not_contains_nocase: String
  pair_starts_with: String
  pair_starts_with_nocase: String
  pair_not_starts_with: String
  pair_not_starts_with_nocase: String
  pair_ends_with: String
  pair_ends_with_nocase: String
  pair_not_ends_with: String
  pair_not_ends_with_nocase: String
  sender: MATIC_Bytes
  sender_not: MATIC_Bytes
  sender_in: [MATIC_Bytes!]
  sender_not_in: [MATIC_Bytes!]
  sender_contains: MATIC_Bytes
  sender_not_contains: MATIC_Bytes
  amount0In: MATIC_BigDecimal
  amount0In_not: MATIC_BigDecimal
  amount0In_gt: MATIC_BigDecimal
  amount0In_lt: MATIC_BigDecimal
  amount0In_gte: MATIC_BigDecimal
  amount0In_lte: MATIC_BigDecimal
  amount0In_in: [MATIC_BigDecimal!]
  amount0In_not_in: [MATIC_BigDecimal!]
  amount1In: MATIC_BigDecimal
  amount1In_not: MATIC_BigDecimal
  amount1In_gt: MATIC_BigDecimal
  amount1In_lt: MATIC_BigDecimal
  amount1In_gte: MATIC_BigDecimal
  amount1In_lte: MATIC_BigDecimal
  amount1In_in: [MATIC_BigDecimal!]
  amount1In_not_in: [MATIC_BigDecimal!]
  amount0Out: MATIC_BigDecimal
  amount0Out_not: MATIC_BigDecimal
  amount0Out_gt: MATIC_BigDecimal
  amount0Out_lt: MATIC_BigDecimal
  amount0Out_gte: MATIC_BigDecimal
  amount0Out_lte: MATIC_BigDecimal
  amount0Out_in: [MATIC_BigDecimal!]
  amount0Out_not_in: [MATIC_BigDecimal!]
  amount1Out: MATIC_BigDecimal
  amount1Out_not: MATIC_BigDecimal
  amount1Out_gt: MATIC_BigDecimal
  amount1Out_lt: MATIC_BigDecimal
  amount1Out_gte: MATIC_BigDecimal
  amount1Out_lte: MATIC_BigDecimal
  amount1Out_in: [MATIC_BigDecimal!]
  amount1Out_not_in: [MATIC_BigDecimal!]
  to: MATIC_Bytes
  to_not: MATIC_Bytes
  to_in: [MATIC_Bytes!]
  to_not_in: [MATIC_Bytes!]
  to_contains: MATIC_Bytes
  to_not_contains: MATIC_Bytes
  logIndex: BigInt
  logIndex_not: BigInt
  logIndex_gt: BigInt
  logIndex_lt: BigInt
  logIndex_gte: BigInt
  logIndex_lte: BigInt
  logIndex_in: [BigInt!]
  logIndex_not_in: [BigInt!]
  amountUSD: MATIC_BigDecimal
  amountUSD_not: MATIC_BigDecimal
  amountUSD_gt: MATIC_BigDecimal
  amountUSD_lt: MATIC_BigDecimal
  amountUSD_gte: MATIC_BigDecimal
  amountUSD_lte: MATIC_BigDecimal
  amountUSD_in: [MATIC_BigDecimal!]
  amountUSD_not_in: [MATIC_BigDecimal!]
}

enum MATIC_Swap_orderBy {
  id
  transaction
  timestamp
  pair
  sender
  amount0In
  amount1In
  amount0Out
  amount1Out
  to
  logIndex
  amountUSD
}

type MATIC_Token {
  id: ID!
  factory: MATIC_Factory!
  symbol: String!
  name: String!
  decimals: BigInt!
  totalSupply: BigInt!
  volume: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  untrackedVolumeUSD: MATIC_BigDecimal!
  txCount: BigInt!
  liquidity: MATIC_BigDecimal!
  derivedETH: MATIC_BigDecimal!
  whitelistPairs(skip: Int = 0, first: Int = 100, orderBy: MATIC_Pair_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Pair_filter): [MATIC_Pair!]!
  hourData(skip: Int = 0, first: Int = 100, orderBy: MATIC_TokenHourData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_TokenHourData_filter): [MATIC_TokenHourData!]!
  dayData(skip: Int = 0, first: Int = 100, orderBy: MATIC_TokenDayData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_TokenDayData_filter): [MATIC_TokenDayData!]!
  basePairs(skip: Int = 0, first: Int = 100, orderBy: MATIC_Pair_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Pair_filter): [MATIC_Pair!]!
  quotePairs(skip: Int = 0, first: Int = 100, orderBy: MATIC_Pair_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Pair_filter): [MATIC_Pair!]!
  basePairsDayData(skip: Int = 0, first: Int = 100, orderBy: MATIC_PairDayData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_PairDayData_filter): [MATIC_PairDayData!]!
  quotePairsDayData(skip: Int = 0, first: Int = 100, orderBy: MATIC_PairDayData_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_PairDayData_filter): [MATIC_PairDayData!]!
}

input MATIC_Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  factory: String
  factory_not: String
  factory_gt: String
  factory_lt: String
  factory_gte: String
  factory_lte: String
  factory_in: [String!]
  factory_not_in: [String!]
  factory_contains: String
  factory_contains_nocase: String
  factory_not_contains: String
  factory_not_contains_nocase: String
  factory_starts_with: String
  factory_starts_with_nocase: String
  factory_not_starts_with: String
  factory_not_starts_with_nocase: String
  factory_ends_with: String
  factory_ends_with_nocase: String
  factory_not_ends_with: String
  factory_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  totalSupply: BigInt
  totalSupply_not: BigInt
  totalSupply_gt: BigInt
  totalSupply_lt: BigInt
  totalSupply_gte: BigInt
  totalSupply_lte: BigInt
  totalSupply_in: [BigInt!]
  totalSupply_not_in: [BigInt!]
  volume: MATIC_BigDecimal
  volume_not: MATIC_BigDecimal
  volume_gt: MATIC_BigDecimal
  volume_lt: MATIC_BigDecimal
  volume_gte: MATIC_BigDecimal
  volume_lte: MATIC_BigDecimal
  volume_in: [MATIC_BigDecimal!]
  volume_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  untrackedVolumeUSD: MATIC_BigDecimal
  untrackedVolumeUSD_not: MATIC_BigDecimal
  untrackedVolumeUSD_gt: MATIC_BigDecimal
  untrackedVolumeUSD_lt: MATIC_BigDecimal
  untrackedVolumeUSD_gte: MATIC_BigDecimal
  untrackedVolumeUSD_lte: MATIC_BigDecimal
  untrackedVolumeUSD_in: [MATIC_BigDecimal!]
  untrackedVolumeUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidity: MATIC_BigDecimal
  liquidity_not: MATIC_BigDecimal
  liquidity_gt: MATIC_BigDecimal
  liquidity_lt: MATIC_BigDecimal
  liquidity_gte: MATIC_BigDecimal
  liquidity_lte: MATIC_BigDecimal
  liquidity_in: [MATIC_BigDecimal!]
  liquidity_not_in: [MATIC_BigDecimal!]
  derivedETH: MATIC_BigDecimal
  derivedETH_not: MATIC_BigDecimal
  derivedETH_gt: MATIC_BigDecimal
  derivedETH_lt: MATIC_BigDecimal
  derivedETH_gte: MATIC_BigDecimal
  derivedETH_lte: MATIC_BigDecimal
  derivedETH_in: [MATIC_BigDecimal!]
  derivedETH_not_in: [MATIC_BigDecimal!]
  whitelistPairs: [String!]
  whitelistPairs_not: [String!]
  whitelistPairs_contains: [String!]
  whitelistPairs_contains_nocase: [String!]
  whitelistPairs_not_contains: [String!]
  whitelistPairs_not_contains_nocase: [String!]
}

enum MATIC_Token_orderBy {
  id
  factory
  symbol
  name
  decimals
  totalSupply
  volume
  volumeUSD
  untrackedVolumeUSD
  txCount
  liquidity
  derivedETH
  whitelistPairs
  hourData
  dayData
  basePairs
  quotePairs
  basePairsDayData
  quotePairsDayData
}

type MATIC_TokenDayData {
  id: ID!
  date: Int!
  token: MATIC_Token!
  volume: MATIC_BigDecimal!
  volumeETH: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  txCount: BigInt!
  liquidity: MATIC_BigDecimal!
  liquidityETH: MATIC_BigDecimal!
  liquidityUSD: MATIC_BigDecimal!
  priceUSD: MATIC_BigDecimal!
}

input MATIC_TokenDayData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  volume: MATIC_BigDecimal
  volume_not: MATIC_BigDecimal
  volume_gt: MATIC_BigDecimal
  volume_lt: MATIC_BigDecimal
  volume_gte: MATIC_BigDecimal
  volume_lte: MATIC_BigDecimal
  volume_in: [MATIC_BigDecimal!]
  volume_not_in: [MATIC_BigDecimal!]
  volumeETH: MATIC_BigDecimal
  volumeETH_not: MATIC_BigDecimal
  volumeETH_gt: MATIC_BigDecimal
  volumeETH_lt: MATIC_BigDecimal
  volumeETH_gte: MATIC_BigDecimal
  volumeETH_lte: MATIC_BigDecimal
  volumeETH_in: [MATIC_BigDecimal!]
  volumeETH_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidity: MATIC_BigDecimal
  liquidity_not: MATIC_BigDecimal
  liquidity_gt: MATIC_BigDecimal
  liquidity_lt: MATIC_BigDecimal
  liquidity_gte: MATIC_BigDecimal
  liquidity_lte: MATIC_BigDecimal
  liquidity_in: [MATIC_BigDecimal!]
  liquidity_not_in: [MATIC_BigDecimal!]
  liquidityETH: MATIC_BigDecimal
  liquidityETH_not: MATIC_BigDecimal
  liquidityETH_gt: MATIC_BigDecimal
  liquidityETH_lt: MATIC_BigDecimal
  liquidityETH_gte: MATIC_BigDecimal
  liquidityETH_lte: MATIC_BigDecimal
  liquidityETH_in: [MATIC_BigDecimal!]
  liquidityETH_not_in: [MATIC_BigDecimal!]
  liquidityUSD: MATIC_BigDecimal
  liquidityUSD_not: MATIC_BigDecimal
  liquidityUSD_gt: MATIC_BigDecimal
  liquidityUSD_lt: MATIC_BigDecimal
  liquidityUSD_gte: MATIC_BigDecimal
  liquidityUSD_lte: MATIC_BigDecimal
  liquidityUSD_in: [MATIC_BigDecimal!]
  liquidityUSD_not_in: [MATIC_BigDecimal!]
  priceUSD: MATIC_BigDecimal
  priceUSD_not: MATIC_BigDecimal
  priceUSD_gt: MATIC_BigDecimal
  priceUSD_lt: MATIC_BigDecimal
  priceUSD_gte: MATIC_BigDecimal
  priceUSD_lte: MATIC_BigDecimal
  priceUSD_in: [MATIC_BigDecimal!]
  priceUSD_not_in: [MATIC_BigDecimal!]
}

enum MATIC_TokenDayData_orderBy {
  id
  date
  token
  volume
  volumeETH
  volumeUSD
  txCount
  liquidity
  liquidityETH
  liquidityUSD
  priceUSD
}

type MATIC_TokenHourData {
  id: ID!
  date: Int!
  token: MATIC_Token!
  volume: MATIC_BigDecimal!
  volumeETH: MATIC_BigDecimal!
  volumeUSD: MATIC_BigDecimal!
  txCount: BigInt!
  liquidity: MATIC_BigDecimal!
  liquidityETH: MATIC_BigDecimal!
  liquidityUSD: MATIC_BigDecimal!
  priceUSD: MATIC_BigDecimal!
}

input MATIC_TokenHourData_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  date: Int
  date_not: Int
  date_gt: Int
  date_lt: Int
  date_gte: Int
  date_lte: Int
  date_in: [Int!]
  date_not_in: [Int!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  volume: MATIC_BigDecimal
  volume_not: MATIC_BigDecimal
  volume_gt: MATIC_BigDecimal
  volume_lt: MATIC_BigDecimal
  volume_gte: MATIC_BigDecimal
  volume_lte: MATIC_BigDecimal
  volume_in: [MATIC_BigDecimal!]
  volume_not_in: [MATIC_BigDecimal!]
  volumeETH: MATIC_BigDecimal
  volumeETH_not: MATIC_BigDecimal
  volumeETH_gt: MATIC_BigDecimal
  volumeETH_lt: MATIC_BigDecimal
  volumeETH_gte: MATIC_BigDecimal
  volumeETH_lte: MATIC_BigDecimal
  volumeETH_in: [MATIC_BigDecimal!]
  volumeETH_not_in: [MATIC_BigDecimal!]
  volumeUSD: MATIC_BigDecimal
  volumeUSD_not: MATIC_BigDecimal
  volumeUSD_gt: MATIC_BigDecimal
  volumeUSD_lt: MATIC_BigDecimal
  volumeUSD_gte: MATIC_BigDecimal
  volumeUSD_lte: MATIC_BigDecimal
  volumeUSD_in: [MATIC_BigDecimal!]
  volumeUSD_not_in: [MATIC_BigDecimal!]
  txCount: BigInt
  txCount_not: BigInt
  txCount_gt: BigInt
  txCount_lt: BigInt
  txCount_gte: BigInt
  txCount_lte: BigInt
  txCount_in: [BigInt!]
  txCount_not_in: [BigInt!]
  liquidity: MATIC_BigDecimal
  liquidity_not: MATIC_BigDecimal
  liquidity_gt: MATIC_BigDecimal
  liquidity_lt: MATIC_BigDecimal
  liquidity_gte: MATIC_BigDecimal
  liquidity_lte: MATIC_BigDecimal
  liquidity_in: [MATIC_BigDecimal!]
  liquidity_not_in: [MATIC_BigDecimal!]
  liquidityETH: MATIC_BigDecimal
  liquidityETH_not: MATIC_BigDecimal
  liquidityETH_gt: MATIC_BigDecimal
  liquidityETH_lt: MATIC_BigDecimal
  liquidityETH_gte: MATIC_BigDecimal
  liquidityETH_lte: MATIC_BigDecimal
  liquidityETH_in: [MATIC_BigDecimal!]
  liquidityETH_not_in: [MATIC_BigDecimal!]
  liquidityUSD: MATIC_BigDecimal
  liquidityUSD_not: MATIC_BigDecimal
  liquidityUSD_gt: MATIC_BigDecimal
  liquidityUSD_lt: MATIC_BigDecimal
  liquidityUSD_gte: MATIC_BigDecimal
  liquidityUSD_lte: MATIC_BigDecimal
  liquidityUSD_in: [MATIC_BigDecimal!]
  liquidityUSD_not_in: [MATIC_BigDecimal!]
  priceUSD: MATIC_BigDecimal
  priceUSD_not: MATIC_BigDecimal
  priceUSD_gt: MATIC_BigDecimal
  priceUSD_lt: MATIC_BigDecimal
  priceUSD_gte: MATIC_BigDecimal
  priceUSD_lte: MATIC_BigDecimal
  priceUSD_in: [MATIC_BigDecimal!]
  priceUSD_not_in: [MATIC_BigDecimal!]
}

enum MATIC_TokenHourData_orderBy {
  id
  date
  token
  volume
  volumeETH
  volumeUSD
  txCount
  liquidity
  liquidityETH
  liquidityUSD
  priceUSD
}

type MATIC_Transaction {
  id: ID!
  blockNumber: BigInt!
  timestamp: BigInt!
  mints(skip: Int = 0, first: Int = 100, orderBy: MATIC_Mint_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Mint_filter): [MATIC_Mint]!
  burns(skip: Int = 0, first: Int = 100, orderBy: MATIC_Burn_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Burn_filter): [MATIC_Burn]!
  swaps(skip: Int = 0, first: Int = 100, orderBy: MATIC_Swap_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_Swap_filter): [MATIC_Swap]!
}

input MATIC_Transaction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  mints: [String!]
  mints_not: [String!]
  mints_contains: [String!]
  mints_contains_nocase: [String!]
  mints_not_contains: [String!]
  mints_not_contains_nocase: [String!]
  burns: [String!]
  burns_not: [String!]
  burns_contains: [String!]
  burns_contains_nocase: [String!]
  burns_not_contains: [String!]
  burns_not_contains_nocase: [String!]
  swaps: [String!]
  swaps_not: [String!]
  swaps_contains: [String!]
  swaps_contains_nocase: [String!]
  swaps_not_contains: [String!]
  swaps_not_contains_nocase: [String!]
}

enum MATIC_Transaction_orderBy {
  id
  blockNumber
  timestamp
  mints
  burns
  swaps
}

type MATIC_User {
  id: ID!
  liquidityPositions(skip: Int = 0, first: Int = 100, orderBy: MATIC_LiquidityPosition_orderBy, orderDirection: MATIC_OrderDirection, where: MATIC_LiquidityPosition_filter): [MATIC_LiquidityPosition!]!
}

input MATIC_User_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
}

enum MATIC_User_orderBy {
  id
  liquidityPositions
}

type Query {
  MATIC_user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_User
  MATIC_users(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_User_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_User!]!
  MATIC_bundle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Bundle
  MATIC_bundles(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Bundle_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Bundle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Bundle!]!
  MATIC_factory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Factory
  MATIC_factories(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Factory_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Factory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Factory!]!
  MATIC_hourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_HourData
  MATIC_hourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_HourData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_HourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_HourData!]!
  MATIC_dayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_DayData
  MATIC_dayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_DayData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_DayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_DayData!]!
  MATIC_token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Token
  MATIC_tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Token_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Token!]!
  MATIC_tokenHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_TokenHourData
  MATIC_tokenHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_TokenHourData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_TokenHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_TokenHourData!]!
  MATIC_tokenDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_TokenDayData
  MATIC_tokenDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_TokenDayData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_TokenDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_TokenDayData!]!
  MATIC_pair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Pair
  MATIC_pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Pair_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Pair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Pair!]!
  MATIC_pairHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_PairHourData
  MATIC_pairHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_PairHourData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_PairHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_PairHourData!]!
  MATIC_pairDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_PairDayData
  MATIC_pairDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_PairDayData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_PairDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_PairDayData!]!
  MATIC_liquidityPosition(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_LiquidityPosition
  MATIC_liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_LiquidityPosition_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_LiquidityPosition_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_LiquidityPosition!]!
  MATIC_liquidityPositionSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_LiquidityPositionSnapshot
  MATIC_liquidityPositionSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_LiquidityPositionSnapshot_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_LiquidityPositionSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_LiquidityPositionSnapshot!]!
  MATIC_transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Transaction
  MATIC_transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Transaction_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Transaction!]!
  MATIC_mint(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Mint
  MATIC_mints(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Mint_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Mint_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Mint!]!
  MATIC_burn(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Burn
  MATIC_burns(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Burn_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Burn_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Burn!]!
  MATIC_swap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Swap
  MATIC_swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Swap_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Swap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Swap!]!

  """Access to subgraph metadata"""
  MATIC__meta(block: MATIC_Block_height): MATIC__Meta_
  ETHEREUM_user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_User
  ETHEREUM_users(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_User_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_User!]!
  ETHEREUM_bundle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Bundle
  ETHEREUM_bundles(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Bundle_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Bundle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Bundle!]!
  ETHEREUM_factory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Factory
  ETHEREUM_factories(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Factory_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Factory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Factory!]!
  ETHEREUM_hourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_HourData
  ETHEREUM_hourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_HourData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_HourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_HourData!]!
  ETHEREUM_dayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_DayData
  ETHEREUM_dayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_DayData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_DayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_DayData!]!
  ETHEREUM_token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Token
  ETHEREUM_tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Token_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Token!]!
  ETHEREUM_tokenHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_TokenHourData
  ETHEREUM_tokenHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_TokenHourData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_TokenHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_TokenHourData!]!
  ETHEREUM_tokenDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_TokenDayData
  ETHEREUM_tokenDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_TokenDayData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_TokenDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_TokenDayData!]!
  ETHEREUM_pair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Pair
  ETHEREUM_pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Pair_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Pair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Pair!]!
  ETHEREUM_pairHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_PairHourData
  ETHEREUM_pairHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_PairHourData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_PairHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_PairHourData!]!
  ETHEREUM_pairDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_PairDayData
  ETHEREUM_pairDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_PairDayData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_PairDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_PairDayData!]!
  ETHEREUM_liquidityPosition(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_LiquidityPosition
  ETHEREUM_liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_LiquidityPosition_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_LiquidityPosition_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_LiquidityPosition!]!
  ETHEREUM_liquidityPositionSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_LiquidityPositionSnapshot
  ETHEREUM_liquidityPositionSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_LiquidityPositionSnapshot_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_LiquidityPositionSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_LiquidityPositionSnapshot!]!
  ETHEREUM_transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Transaction
  ETHEREUM_transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Transaction_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Transaction!]!
  ETHEREUM_mint(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Mint
  ETHEREUM_mints(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Mint_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Mint_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Mint!]!
  ETHEREUM_burn(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Burn
  ETHEREUM_burns(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Burn_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Burn_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Burn!]!
  ETHEREUM_swap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Swap
  ETHEREUM_swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Swap_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Swap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Swap!]!
  ETHEREUM_tokenSearch(
    text: String!
    first: Int = 100
    skip: Int = 0

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Token!]!
  ETHEREUM_pairSearch(
    text: String!
    first: Int = 100
    skip: Int = 0

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Pair!]!
  ETHEREUM_userSearch(
    text: String!
    first: Int = 100
    skip: Int = 0

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_User!]!

  """Access to subgraph metadata"""
  ETHEREUM__meta(block: ETHEREUM_Block_height): ETHEREUM__Meta_
}

type Subscription {
  MATIC_user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_User
  MATIC_users(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_User_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_User!]!
  MATIC_bundle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Bundle
  MATIC_bundles(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Bundle_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Bundle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Bundle!]!
  MATIC_factory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Factory
  MATIC_factories(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Factory_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Factory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Factory!]!
  MATIC_hourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_HourData
  MATIC_hourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_HourData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_HourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_HourData!]!
  MATIC_dayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_DayData
  MATIC_dayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_DayData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_DayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_DayData!]!
  MATIC_token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Token
  MATIC_tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Token_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Token!]!
  MATIC_tokenHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_TokenHourData
  MATIC_tokenHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_TokenHourData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_TokenHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_TokenHourData!]!
  MATIC_tokenDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_TokenDayData
  MATIC_tokenDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_TokenDayData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_TokenDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_TokenDayData!]!
  MATIC_pair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Pair
  MATIC_pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Pair_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Pair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Pair!]!
  MATIC_pairHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_PairHourData
  MATIC_pairHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_PairHourData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_PairHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_PairHourData!]!
  MATIC_pairDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_PairDayData
  MATIC_pairDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_PairDayData_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_PairDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_PairDayData!]!
  MATIC_liquidityPosition(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_LiquidityPosition
  MATIC_liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_LiquidityPosition_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_LiquidityPosition_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_LiquidityPosition!]!
  MATIC_liquidityPositionSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_LiquidityPositionSnapshot
  MATIC_liquidityPositionSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_LiquidityPositionSnapshot_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_LiquidityPositionSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_LiquidityPositionSnapshot!]!
  MATIC_transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Transaction
  MATIC_transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Transaction_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Transaction!]!
  MATIC_mint(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Mint
  MATIC_mints(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Mint_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Mint_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Mint!]!
  MATIC_burn(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Burn
  MATIC_burns(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Burn_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Burn_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Burn!]!
  MATIC_swap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MATIC_Swap
  MATIC_swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: MATIC_Swap_orderBy
    orderDirection: MATIC_OrderDirection
    where: MATIC_Swap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: MATIC_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MATIC_Swap!]!

  """Access to subgraph metadata"""
  MATIC__meta(block: MATIC_Block_height): MATIC__Meta_
  ETHEREUM_user(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_User
  ETHEREUM_users(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_User_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_User_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_User!]!
  ETHEREUM_bundle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Bundle
  ETHEREUM_bundles(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Bundle_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Bundle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Bundle!]!
  ETHEREUM_factory(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Factory
  ETHEREUM_factories(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Factory_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Factory_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Factory!]!
  ETHEREUM_hourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_HourData
  ETHEREUM_hourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_HourData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_HourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_HourData!]!
  ETHEREUM_dayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_DayData
  ETHEREUM_dayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_DayData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_DayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_DayData!]!
  ETHEREUM_token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Token
  ETHEREUM_tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Token_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Token!]!
  ETHEREUM_tokenHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_TokenHourData
  ETHEREUM_tokenHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_TokenHourData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_TokenHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_TokenHourData!]!
  ETHEREUM_tokenDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_TokenDayData
  ETHEREUM_tokenDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_TokenDayData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_TokenDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_TokenDayData!]!
  ETHEREUM_pair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Pair
  ETHEREUM_pairs(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Pair_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Pair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Pair!]!
  ETHEREUM_pairHourData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_PairHourData
  ETHEREUM_pairHourDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_PairHourData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_PairHourData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_PairHourData!]!
  ETHEREUM_pairDayData(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_PairDayData
  ETHEREUM_pairDayDatas(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_PairDayData_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_PairDayData_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_PairDayData!]!
  ETHEREUM_liquidityPosition(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_LiquidityPosition
  ETHEREUM_liquidityPositions(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_LiquidityPosition_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_LiquidityPosition_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_LiquidityPosition!]!
  ETHEREUM_liquidityPositionSnapshot(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_LiquidityPositionSnapshot
  ETHEREUM_liquidityPositionSnapshots(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_LiquidityPositionSnapshot_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_LiquidityPositionSnapshot_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_LiquidityPositionSnapshot!]!
  ETHEREUM_transaction(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Transaction
  ETHEREUM_transactions(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Transaction_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Transaction_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Transaction!]!
  ETHEREUM_mint(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Mint
  ETHEREUM_mints(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Mint_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Mint_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Mint!]!
  ETHEREUM_burn(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Burn
  ETHEREUM_burns(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Burn_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Burn_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Burn!]!
  ETHEREUM_swap(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ETHEREUM_Swap
  ETHEREUM_swaps(
    skip: Int = 0
    first: Int = 100
    orderBy: ETHEREUM_Swap_orderBy
    orderDirection: ETHEREUM_OrderDirection
    where: ETHEREUM_Swap_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: ETHEREUM_Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ETHEREUM_Swap!]!

  """Access to subgraph metadata"""
  ETHEREUM__meta(block: ETHEREUM_Block_height): ETHEREUM__Meta_
}
